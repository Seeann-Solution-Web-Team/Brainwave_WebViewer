{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"C:\\\\Users\\\\tank6\\\\Desktop\\\\React\\\\brainwave_webviewer\\\\src\\\\pages\\\\GLGraph.js\";\nimport React from 'react';\nimport ScrollBar from './ScrollBar';\n\nclass GLGraph extends React.Component {\n  constructor(props) {\n    super(props);\n    this.canvasRef = /*#__PURE__*/React.createRef();\n    this.gridCanvasRef = /*#__PURE__*/React.createRef();\n    this.gridContext = null;\n    this.scrollBarRef = null;\n    this.isPlaying = false;\n    this.count = 1000;\n    this.deltaTime = 0;\n    this.prevTime = 0;\n    this.textWidth = 100;\n    this.timelineHeight = 50;\n    this.verticalScrollPos = 0; //WebGL\n\n    this.glContext = null;\n    this.vertexBuffer = null;\n    this.shaderProgram = null;\n    this.vertexShader = null;\n    this.fragShader = null;\n    this.coordAttr = null;\n    this.resolutionUniform = null; //Bind Functions\n\n    this.loop = this.loop.bind(this);\n    this.play = this.play.bind(this);\n    this.stop = this.stop.bind(this);\n    this.setoffset = this.setoffset.bind(this);\n    this.updatecount = this.updatecount.bind(this);\n    var channelCount = props.channels;\n    this.peakArray = [];\n    this.compressedPeakArray = [];\n    this.peakLength = 0;\n    this.channelEnabled = [];\n    this.channelNames = [];\n    this.peakOffset = props.count / -2;\n    this.peakMaxOffset = 0;\n    this.peakMinOffset = props.count / -2; //Create Test Samples\n\n    var c;\n    var i;\n\n    for (c = 0; c < channelCount; c++) {\n      this.peakArray.push([]);\n      this.channelEnabled.push(true);\n      this.channelNames.push(c.toString().padStart(4, '0'));\n\n      for (i = 0; i < 100000; i++) {\n        this.peakArray[c].push(0);\n      }\n    }\n\n    this.peakLength = 100000;\n    this.peakMaxOffset = this.peakLength - this.count / 2;\n  }\n\n  componentDidMount() {\n    this.gridContext = this.gridCanvasRef.current.getContext('2d');\n    this.gridContext.fillStyle = 'black';\n    this.gridContext.lineWidth = 1;\n    this.gridContext.shadowBlur = 0;\n    this.gridContext.font = 16 + 'px malgun gothic';\n    var canvas = this.canvasRef.current;\n\n    try {\n      this.glContext = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\n    } catch (e) {}\n\n    if (this.glContext) {\n      this.initWebGL(this.glContext);\n    } else {\n      alert(\"Unable to initialize WebGL. Your browser may not support it.\");\n      this.glContext = null;\n    }\n\n    this.draw(true);\n  }\n\n  componentDidUpdate() {\n    this.draw(true);\n  }\n\n  componentWillUnmount() {\n    this.stop();\n  }\n\n  initWebGL(gl) {\n    //#####Vertex Buffer#####\n    this.vertexBuffer = gl.createBuffer(); //#####Shader#####\n\n    var vsCode = 'attribute vec2 coordinates;' + 'uniform vec2 u_resolution;' + 'void main(void) {' + 'vec2 zeroToOne = coordinates / u_resolution;' + 'vec2 zeroToTwo = zeroToOne * 2.0;' + 'vec2 clipSpace = zeroToTwo - 1.0;' + 'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);' + '}';\n    var fsCode = 'void main(void) {' + 'gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);' + '}';\n    this.vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    this.fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(this.vertexShader, vsCode);\n    gl.compileShader(this.vertexShader);\n    gl.shaderSource(this.fragShader, fsCode);\n    gl.compileShader(this.fragShader);\n    var compiled = gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS);\n    console.log('Shader compiled successfully: ' + compiled);\n    var compilationLog = gl.getShaderInfoLog(this.vertexShader);\n    console.log('Shader compiler log: ' + compilationLog); //Create shader program\n\n    this.shaderProgram = gl.createProgram();\n    gl.attachShader(this.shaderProgram, this.vertexShader);\n    gl.attachShader(this.shaderProgram, this.fragShader);\n    gl.linkProgram(this.shaderProgram);\n\n    if (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {\n      var info = gl.getProgramInfoLog(this.shaderProgram);\n      alert('Could not compile WebGL program. \\n\\n' + info);\n    }\n\n    this.coordAttr = gl.getAttribLocation(this.shaderProgram, 'coordinates');\n    this.resolutionUniform = gl.getUniformLocation(this.shaderProgram, \"u_resolution\");\n    this.glContext.useProgram(this.shaderProgram);\n    console.log('WebGL Initialized Successfully');\n  } //Play\n\n\n  play() {\n    if (this.isPlaying) return; //Rewind\n\n    if (this.peakOffset === this.peakMaxOffset) {\n      this.peakOffset = this.peakMinOffset;\n    }\n\n    this.prevTime = new Date().getTime();\n    this.isPlaying = true;\n    this.drawGrid();\n    requestAnimationFrame(this.loop);\n    if (this.props.onPlayStateChanged !== undefined) this.props.onPlayStateChanged();\n  }\n\n  stop() {\n    if (!this.isPlaying) return;\n    this.isPlaying = false;\n    if (this.props.onPlayStateChanged !== undefined) this.props.onPlayStateChanged();\n  }\n\n  togglePlay() {\n    if (this.isPlaying) this.stop();else this.play();\n  } //Controls\n\n\n  setfile(file) {\n    this.currentFile = file; //file.getFilteredAmpData(60, 10, file.sampleRate);\n\n    if (file.notchFilterMode === 0) {\n      this.peakArray = file.getNormalizedAmpData();\n    } else {\n      var notchFreq = file.notchFilterMode === 1 ? 50 : 60;\n      this.peakArray = file.getFilteredAmpData(notchFreq, 10, file.sampleRate);\n    }\n\n    this.peakLength = this.currentFile.timestamps.length; //Compress Peaks\n\n    var step = 5;\n    var c = 0;\n    var i = 0;\n    var j = 0;\n    var len = Math.ceil(this.peakLength / step);\n\n    for (c = 0; c < this.peakArray.length; c++) {\n      this.compressedPeakArray.push([]);\n\n      for (i = 0; i < len; i++) {\n        var value = 0.0;\n\n        for (j = 0; j < step; j++) {\n          var idx = i * step + j;\n          if (idx === this.peakArray[c].length) break;else if (Math.abs(this.peakArray[c][idx]) > value) {\n            value = Math.abs(this.peakArray[c][idx]);\n          }\n        }\n\n        this.compressedPeakArray[c].push(value);\n      }\n    } //Update Properties\n\n\n    this.updatecount();\n    this.peakMaxOffset = this.peakLength - this.count / 2;\n    this.peakMinOffset = this.count / -2;\n    this.peakOffset = this.peakMinOffset;\n    this.channelEnabled = [];\n\n    for (i = 0; i < this.peakArray.length; i++) {\n      this.channelEnabled.push(true);\n    }\n\n    var channelData = file.getChannelData();\n    this.channelNames = [];\n\n    for (i = 0; i < channelData.length; i++) {\n      this.channelNames.push(channelData[i].customName);\n    }\n\n    this.scrollBarRef.setHandlePosition(0);\n    this.draw(true);\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged(0);\n  }\n\n  setchannelsenabled(arr) {\n    var j = 0;\n\n    for (var i = 0; i < this.channelEnabled.length; i++) {\n      if (arr[j] === i) {\n        this.channelEnabled[i] = true;\n\n        if (j < arr.length - 1) {\n          j++;\n        }\n      } else {\n        this.channelEnabled[i] = false;\n      }\n    }\n\n    this.verticalScrollPos = 0;\n    this.draw(true);\n  }\n\n  setoffset(pos) {\n    this.peakOffset = Math.floor((this.peakMaxOffset + this.count / 2) * pos) - this.count / 2;\n    if (!this.isPlaying) this.draw();\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged(pos);\n  }\n\n  updatecount() {\n    if (this.currentFile === undefined) this.count = 1000;else this.count = this.currentFile.sampleRate / 1000 * this.props.timescale;\n  }\n\n  addverticalscroll(v) {\n    var maxPos = 0;\n\n    for (var i = 0; i < this.channelEnabled.length; i++) {\n      if (this.channelEnabled[i]) maxPos++;\n    }\n\n    var currentHeight = Math.max(50, Math.min(150, (this.props.height - this.timelineHeight - this.props.margin * maxPos) / maxPos));\n    maxPos = Math.max(0, (currentHeight + this.props.margin) * maxPos - (this.props.height - this.timelineHeight));\n    this.verticalScrollPos = Math.max(0, Math.min(maxPos, this.verticalScrollPos + v));\n    if (!this.isPlaying) this.draw();\n    this.drawGrid();\n  }\n\n  next() {\n    if (this.isPlaying) this.peakOffset += Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * this.props.speed);else this.peakOffset += this.count;\n    this.peakOffset = Math.min(this.peakOffset, this.peakMaxOffset);\n    this.peakOffset = Math.max(this.peakOffset, this.peakMinOffset);\n    if (!this.isPlaying) this.draw();\n    var pos = (this.peakOffset + this.count / 2) / (this.peakMaxOffset + this.count / 2);\n    this.scrollBarRef.setHandlePosition(pos);\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged(pos);\n  }\n\n  prev() {\n    if (this.isPlaying) this.peakOffset -= Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * this.props.speed);else this.peakOffset -= this.count;\n    this.peakOffset = Math.min(this.peakOffset, this.peakMaxOffset);\n    this.peakOffset = Math.max(this.peakOffset, this.peakMinOffset);\n    if (!this.isPlaying) this.draw();\n    var pos = (this.peakOffset + this.count / 2) / (this.peakMaxOffset + this.count / 2);\n    this.scrollBarRef.setHandlePosition(pos);\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged(pos);\n  } //Play Loop\n\n\n  loop() {\n    if (!this.isPlaying) return;\n    var now = new Date().getTime();\n    this.deltaTime = now - this.prevTime;\n    this.prevTime = now;\n    this.update();\n    this.draw();\n    requestAnimationFrame(this.loop);\n  }\n\n  update() {\n    this.updatecount();\n    this.peakOffset += Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * (this.deltaTime * 0.001) * this.props.speed);\n\n    if (this.peakOffset > this.peakMaxOffset) {\n      this.peakOffset = this.peakMaxOffset;\n      this.stop();\n    }\n\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged((this.peakOffset + this.count / 2) / this.peakMaxOffset);\n    if (this.scrollBarRef != null) this.scrollBarRef.setHandlePosition((this.peakOffset + this.count / 2) / (this.peakMaxOffset + this.count / 2));\n  }\n\n  draw(isUpdateGrid) {\n    if (this.peakLength < 2) return;\n    this.updatecount();\n    var channelCount = this.props.channels > this.peakArray.length ? this.peakArray.length : this.props.channels;\n    var len = this.count < this.peakLength ? this.count : this.peakLength;\n    var width = this.props.width - this.textWidth;\n    var widthStep = width / this.count;\n    var currentHeight = Math.max(50, (this.props.height - this.timelineHeight - this.props.margin * channelCount) / channelCount); //Math.max(50, Math.min(150, (this.props.height - this.timelineHeight - (this.props.margin * channelCount)) / channelCount));\n\n    var halfHeight = currentHeight / 2;\n    var startX = widthStep * Math.min(this.peakOffset, 0) * -1 + this.textWidth;\n    var startY = 0;\n    var topMargin = Math.max(this.props.height - this.timelineHeight - (currentHeight + this.props.margin) * channelCount, 0) / 2;\n    this.glContext.clearColor(0.0, 0.0, 0.0, 1.0);\n    this.glContext.clear(this.glContext.COLOR_BUFFER_BIT);\n    this.glContext.viewport(0, 0, this.canvasRef.current.width, this.canvasRef.current.height); //Draw Graphs\n\n    var currentIdx = 0;\n    var x = 0;\n    var y = 0;\n    var vertices = [];\n    var c = 0;\n    var i = 0;\n    var drawnChannels = 0;\n\n    for (c = 0; c < this.peakArray.length; c++) {\n      if (!this.channelEnabled[c]) continue;\n      startY = halfHeight * (drawnChannels * 2 + 1) + this.props.margin * drawnChannels + topMargin + this.timelineHeight - this.verticalScrollPos;\n\n      if (startY < -1 * currentHeight - this.props.margin) {\n        drawnChannels++;\n        continue;\n      } else if (startY > this.props.height) break; //Push GL Vertex\n\n\n      vertices.push(startX);\n      vertices.push(this.peakArray[c][Math.max(this.peakOffset, 0)] * halfHeight + startY); //Draw graph\n\n      for (i = 1; i < len + 1; i++) {\n        currentIdx = Math.floor(Math.max(i + this.peakOffset, i));\n        if (currentIdx > this.peakArray[c].length) continue;\n        x = Math.floor(widthStep * i + startX);\n        y = Math.floor(this.peakArray[c][currentIdx] * halfHeight + startY);\n        vertices.push(x);\n        vertices.push(y); //this.canvasContext.lineTo(x, y);\n      }\n\n      vertices.push(this.props.width);\n      vertices.push(NaN);\n      drawnChannels++;\n    }\n\n    this.glContext.enableVertexAttribArray(this.coordAttr);\n    this.glContext.vertexAttribPointer(this.coordAttr, 2, this.glContext.FLOAT, false, 0, 0);\n    this.glContext.uniform2f(this.resolutionUniform, this.canvasRef.current.width, this.canvasRef.current.height); // Pass the vertex data to the buffer\n\n    this.glContext.bindBuffer(this.glContext.ARRAY_BUFFER, this.vertexBuffer);\n    this.glContext.bufferData(this.glContext.ARRAY_BUFFER, new Float32Array(vertices), this.glContext.STATIC_DRAW);\n    this.glContext.drawArrays(this.glContext.LINE_STRIP, 0, Math.floor(vertices.length / 2));\n    if (isUpdateGrid) this.drawGrid();\n  }\n\n  drawGrid() {\n    var channelCount = this.props.channels > this.peakArray.length ? this.peakArray.length : this.props.channels;\n    var width = this.props.width - this.textWidth;\n    var widthStep = width / this.count;\n    var currentHeight = Math.max(50, (this.props.height - this.timelineHeight - this.props.margin * channelCount) / channelCount); //Math.max(50, Math.min(150, (this.props.height - this.timelineHeight - (this.props.margin * channelCount)) / channelCount));\n\n    var halfHeight = currentHeight / 2;\n    var startX = widthStep * Math.min(this.peakOffset, 0) * -1 + this.textWidth;\n    var startY = 0;\n    var topMargin = Math.max(this.props.height - this.timelineHeight - (currentHeight + this.props.margin) * channelCount, 0) / 2;\n    var c = 0;\n    var drawnChannels = 0;\n    this.gridContext.fillStyle = 'white';\n    this.gridContext.clearRect(0, 0, this.props.width, this.props.height);\n\n    for (c = 0; c < this.peakArray.length; c++) {\n      if (!this.channelEnabled[c]) continue;\n      startY = halfHeight * (drawnChannels * 2 + 1) + this.props.margin * drawnChannels + topMargin + this.timelineHeight - this.verticalScrollPos;\n\n      if (startY < -1 * currentHeight - this.props.margin) {\n        drawnChannels++;\n        continue;\n      } else if (startY > this.props.height) break; //Draw canvas channel text\n\n\n      this.gridContext.fillText(this.channelNames[c], 0, startY);\n      this.gridContext.moveTo(startX, this.peakArray[c][Math.max(this.peakOffset, 0)] * halfHeight + startY);\n      drawnChannels++;\n    } //Draw Canvas Grids\n\n\n    var y = this.timelineHeight;\n    this.gridContext.beginPath();\n    this.gridContext.strokeStyle = 'red';\n    this.gridContext.lineWidth = 0.5;\n    this.gridContext.moveTo(width / 2 + this.textWidth, this.timelineHeight);\n    this.gridContext.lineTo(width / 2 + this.textWidth, this.props.height);\n\n    for (c = 0; c < channelCount; c++) {\n      y = c * (currentHeight + this.props.margin) + this.timelineHeight + topMargin - this.verticalScrollPos;\n      this.gridContext.moveTo(this.textWidth, y);\n      this.gridContext.lineTo(this.textWidth + width, y);\n      y += currentHeight;\n      this.gridContext.moveTo(this.textWidth, y);\n      this.gridContext.lineTo(this.textWidth + width, y);\n    }\n\n    this.gridContext.stroke();\n  } //etc\n\n\n  getCanvas() {\n    return this.canvasRef.current;\n  }\n\n  render() {\n    var style = {\n      display: 'flex',\n      flexDirection: 'column'\n    };\n    var graphStyle = {\n      display: 'flex',\n      zIndex: '1',\n      minHeight: Math.floor(this.props.height) + 'px'\n    };\n    var gridStyle = {\n      display: 'flex',\n      position: 'absolute',\n      zIndex: '2'\n    };\n    var scrollStyle = {\n      display: 'flex',\n      position: 'relative',\n      zIndex: '3'\n    };\n    this.peakMaxOffset = this.peakLength - this.count / 2;\n    this.peakMinOffset = this.count / -2;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: style,\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: style,\n        children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n          ref: this.canvasRef,\n          style: graphStyle,\n          id: \"graphCanvas\",\n          width: this.props.width,\n          height: Math.floor(this.props.height)\n          /*this.props.channels * (this.props.height + this.props.margin) + this.timelineHeight*/\n\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 542,\n          columnNumber: 17\n        }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n          ref: this.gridCanvasRef,\n          style: gridStyle,\n          id: \"gridCanvas\",\n          width: this.props.width,\n          height: Math.floor(this.props.height)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 544,\n          columnNumber: 17\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 541,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(ScrollBar, {\n        ref: ref => {\n          this.scrollBarRef = ref;\n        },\n        style: scrollStyle,\n        width: this.props.width,\n        height: \"20\",\n        handleWidth: this.count / (this.peakLength + this.count / 2),\n        onDragStart: this.stop,\n        onDrag: this.setoffset\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 547,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 540,\n      columnNumber: 9\n    }, this);\n  }\n\n}\n\nexport default GLGraph;","map":{"version":3,"sources":["C:/Users/tank6/Desktop/React/brainwave_webviewer/src/pages/GLGraph.js"],"names":["React","ScrollBar","GLGraph","Component","constructor","props","canvasRef","createRef","gridCanvasRef","gridContext","scrollBarRef","isPlaying","count","deltaTime","prevTime","textWidth","timelineHeight","verticalScrollPos","glContext","vertexBuffer","shaderProgram","vertexShader","fragShader","coordAttr","resolutionUniform","loop","bind","play","stop","setoffset","updatecount","channelCount","channels","peakArray","compressedPeakArray","peakLength","channelEnabled","channelNames","peakOffset","peakMaxOffset","peakMinOffset","c","i","push","toString","padStart","componentDidMount","current","getContext","fillStyle","lineWidth","shadowBlur","font","canvas","e","initWebGL","alert","draw","componentDidUpdate","componentWillUnmount","gl","createBuffer","vsCode","fsCode","createShader","VERTEX_SHADER","FRAGMENT_SHADER","shaderSource","compileShader","compiled","getShaderParameter","COMPILE_STATUS","console","log","compilationLog","getShaderInfoLog","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","info","getProgramInfoLog","getAttribLocation","getUniformLocation","useProgram","Date","getTime","drawGrid","requestAnimationFrame","onPlayStateChanged","undefined","togglePlay","setfile","file","currentFile","notchFilterMode","getNormalizedAmpData","notchFreq","getFilteredAmpData","sampleRate","timestamps","length","step","j","len","Math","ceil","value","idx","abs","channelData","getChannelData","customName","setHandlePosition","onOffsetChanged","setchannelsenabled","arr","pos","floor","timescale","addverticalscroll","v","maxPos","currentHeight","max","min","height","margin","next","round","speed","prev","now","update","isUpdateGrid","width","widthStep","halfHeight","startX","startY","topMargin","clearColor","clear","COLOR_BUFFER_BIT","viewport","currentIdx","x","y","vertices","drawnChannels","NaN","enableVertexAttribArray","vertexAttribPointer","FLOAT","uniform2f","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","drawArrays","LINE_STRIP","clearRect","fillText","moveTo","beginPath","strokeStyle","lineTo","stroke","getCanvas","render","style","display","flexDirection","graphStyle","zIndex","minHeight","gridStyle","position","scrollStyle","ref"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport ScrollBar from './ScrollBar';\r\n\r\nclass GLGraph extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.canvasRef = React.createRef();\r\n        this.gridCanvasRef = React.createRef();\r\n        this.gridContext = null;\r\n        this.scrollBarRef = null;\r\n        this.isPlaying = false;\r\n        this.count = 1000;\r\n        this.deltaTime = 0;\r\n        this.prevTime = 0;\r\n        this.textWidth = 100;\r\n        this.timelineHeight = 50;\r\n        this.verticalScrollPos = 0;\r\n\r\n        //WebGL\r\n        this.glContext = null;\r\n        this.vertexBuffer = null;\r\n        this.shaderProgram = null;\r\n        this.vertexShader = null;\r\n        this.fragShader = null;\r\n        this.coordAttr = null;\r\n        this.resolutionUniform = null;\r\n\r\n        //Bind Functions\r\n        this.loop = this.loop.bind(this);\r\n\r\n        this.play = this.play.bind(this);\r\n        this.stop = this.stop.bind(this);\r\n        this.setoffset = this.setoffset.bind(this);\r\n        this.updatecount = this.updatecount.bind(this);\r\n\r\n        var channelCount = props.channels;\r\n        this.peakArray = [];\r\n        this.compressedPeakArray = [];\r\n        this.peakLength = 0;\r\n        this.channelEnabled = [];\r\n        this.channelNames = [];\r\n        this.peakOffset = props.count / -2;\r\n        this.peakMaxOffset = 0;\r\n        this.peakMinOffset = props.count / -2;\r\n\r\n        //Create Test Samples\r\n        var c;\r\n        var i;\r\n        for (c = 0; c < channelCount; c++){\r\n            this.peakArray.push([]);\r\n            this.channelEnabled.push(true);\r\n            this.channelNames.push(c.toString().padStart(4, '0'));\r\n\r\n            for (i = 0; i < 100000; i++){\r\n                this.peakArray[c].push(0);\r\n            }\r\n        }\r\n        this.peakLength = 100000;\r\n        this.peakMaxOffset = this.peakLength - this.count / 2;\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.gridContext = this.gridCanvasRef.current.getContext('2d');\r\n        this.gridContext.fillStyle = 'black';\r\n        this.gridContext.lineWidth = 1;\r\n        this.gridContext.shadowBlur = 0;\r\n        this.gridContext.font = (16) + 'px malgun gothic';\r\n\r\n        var canvas = this.canvasRef.current;\r\n\r\n        try{\r\n            this.glContext = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\r\n        }\r\n        catch (e){}\r\n\r\n        if (this.glContext){\r\n            this.initWebGL(this.glContext);\r\n        }\r\n        else{\r\n            alert(\"Unable to initialize WebGL. Your browser may not support it.\");\r\n            this.glContext = null;\r\n        }\r\n\r\n        this.draw(true);\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        this.draw(true);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        this.stop();\r\n    }\r\n\r\n    initWebGL (gl){\r\n        //#####Vertex Buffer#####\r\n        this.vertexBuffer = gl.createBuffer();\r\n\r\n        //#####Shader#####\r\n        var vsCode =\r\n            'attribute vec2 coordinates;' +\r\n            'uniform vec2 u_resolution;' +\r\n            'void main(void) {' +\r\n                'vec2 zeroToOne = coordinates / u_resolution;' +\r\n                'vec2 zeroToTwo = zeroToOne * 2.0;' +\r\n                'vec2 clipSpace = zeroToTwo - 1.0;' +\r\n                'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);' + \r\n            '}';\r\n        \r\n        var fsCode =\r\n            'void main(void) {' +\r\n               'gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);' +\r\n            '}';\r\n\r\n        this.vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n        this.fragShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        \r\n        gl.shaderSource(this.vertexShader, vsCode);\r\n        gl.compileShader(this.vertexShader);\r\n        gl.shaderSource(this.fragShader, fsCode);\r\n        gl.compileShader(this.fragShader);\r\n\r\n        var compiled = gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS);\r\n        console.log('Shader compiled successfully: ' + compiled);\r\n        var compilationLog = gl.getShaderInfoLog(this.vertexShader);\r\n        console.log('Shader compiler log: ' + compilationLog);\r\n        \r\n        //Create shader program\r\n        this.shaderProgram = gl.createProgram();\r\n        \r\n        gl.attachShader(this.shaderProgram, this.vertexShader);\r\n        gl.attachShader(this.shaderProgram, this.fragShader);\r\n\r\n        gl.linkProgram(this.shaderProgram);\r\n\r\n        if ( !gl.getProgramParameter( this.shaderProgram, gl.LINK_STATUS) ) {\r\n            var info = gl.getProgramInfoLog(this.shaderProgram);\r\n            alert('Could not compile WebGL program. \\n\\n' + info);\r\n        }\r\n\r\n        this.coordAttr = gl.getAttribLocation(this.shaderProgram, 'coordinates');\r\n        this.resolutionUniform = gl.getUniformLocation(this.shaderProgram, \"u_resolution\");\r\n        this.glContext.useProgram(this.shaderProgram);\r\n\r\n        console.log('WebGL Initialized Successfully');\r\n    }\r\n\r\n    //Play\r\n    play (){\r\n        if (this.isPlaying)\r\n            return;\r\n\r\n        //Rewind\r\n        if (this.peakOffset === this.peakMaxOffset){\r\n            this.peakOffset = this.peakMinOffset;\r\n        }\r\n        \r\n        this.prevTime = new Date().getTime();\r\n        this.isPlaying = true;\r\n        this.drawGrid();\r\n        requestAnimationFrame(this.loop);\r\n\r\n        if (this.props.onPlayStateChanged !== undefined)\r\n            this.props.onPlayStateChanged();\r\n    }\r\n    \r\n    stop(){\r\n        if (!this.isPlaying)\r\n            return;\r\n\r\n        this.isPlaying = false;\r\n\r\n        if (this.props.onPlayStateChanged !== undefined)\r\n            this.props.onPlayStateChanged();\r\n    }\r\n\r\n    togglePlay (){\r\n        if (this.isPlaying)\r\n            this.stop();\r\n        else\r\n            this.play();\r\n    }\r\n    \r\n    //Controls\r\n    setfile(file){\r\n        this.currentFile = file;\r\n\r\n        //file.getFilteredAmpData(60, 10, file.sampleRate);\r\n        \r\n        if (file.notchFilterMode === 0){\r\n            this.peakArray = file.getNormalizedAmpData();\r\n        }\r\n        else {\r\n            var notchFreq = file.notchFilterMode === 1 ? 50 : 60;\r\n            this.peakArray = file.getFilteredAmpData(notchFreq, 10, file.sampleRate);\r\n        }\r\n        this.peakLength = this.currentFile.timestamps.length;\r\n\r\n        //Compress Peaks\r\n        var step = 5;\r\n        var c = 0;\r\n        var i = 0;\r\n        var j = 0;\r\n\r\n        var len = Math.ceil(this.peakLength / step);\r\n        for (c = 0; c < this.peakArray.length; c++){\r\n            this.compressedPeakArray.push([]);\r\n\r\n            for (i = 0; i < len; i++){\r\n                var value = 0.0;\r\n                for (j = 0; j < step; j++){\r\n                    var idx = i * step + j;\r\n\r\n                    if (idx === this.peakArray[c].length)\r\n                        break;\r\n                    else if (Math.abs(this.peakArray[c][idx]) > value){\r\n                        value = Math.abs(this.peakArray[c][idx]);\r\n                    }\r\n                }\r\n                \r\n                this.compressedPeakArray[c].push(value);\r\n            }\r\n        }\r\n\r\n        //Update Properties\r\n        this.updatecount();\r\n        this.peakMaxOffset = this.peakLength - this.count / 2;\r\n        this.peakMinOffset = this.count / -2;\r\n        this.peakOffset = this.peakMinOffset;\r\n        \r\n        this.channelEnabled = [];\r\n        for (i = 0; i < this.peakArray.length; i++){\r\n            this.channelEnabled.push(true);\r\n        }\r\n\r\n        var channelData = file.getChannelData();\r\n        this.channelNames = [];\r\n        for (i = 0; i < channelData.length; i++){\r\n            this.channelNames.push(channelData[i].customName);\r\n        }\r\n\r\n        this.scrollBarRef.setHandlePosition(0);\r\n        this.draw(true);\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged(0);\r\n    }\r\n\r\n    setchannelsenabled(arr){\r\n        var j = 0;\r\n        for (var i = 0; i < this.channelEnabled.length; i++){\r\n            if (arr[j] === i){\r\n                this.channelEnabled[i] = true;\r\n                if(j < arr.length - 1){\r\n                    j++;\r\n                }\r\n            }\r\n            else{\r\n                this.channelEnabled[i] = false;\r\n            }\r\n        }\r\n\r\n        this.verticalScrollPos = 0;\r\n        this.draw(true);\r\n    }\r\n\r\n    setoffset(pos){\r\n        this.peakOffset = Math.floor((this.peakMaxOffset + (this.count / 2)) * pos) - (this.count / 2);\r\n        \r\n        if (!this.isPlaying)\r\n            this.draw();\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged(pos);\r\n    }\r\n\r\n    updatecount(){\r\n        if (this.currentFile === undefined)\r\n            this.count = 1000;\r\n        else\r\n            this.count = this.currentFile.sampleRate / 1000 * this.props.timescale;\r\n    }\r\n\r\n    addverticalscroll(v){\r\n        var maxPos = 0;\r\n\r\n        for (var i = 0; i < this.channelEnabled.length; i++){\r\n            if (this.channelEnabled[i])\r\n                maxPos++;\r\n        }\r\n        \r\n        var currentHeight = Math.max(50, Math.min(150, (this.props.height - this.timelineHeight - (this.props.margin * maxPos)) / maxPos));\r\n        maxPos = Math.max(0, ((currentHeight + this.props.margin) * maxPos) - (this.props.height - this.timelineHeight));\r\n\r\n        this.verticalScrollPos = Math.max(0, Math.min(maxPos, this.verticalScrollPos + v));\r\n        \r\n        if (!this.isPlaying)\r\n            this.draw();\r\n            \r\n        this.drawGrid();\r\n    }\r\n\r\n    next(){\r\n        if (this.isPlaying)\r\n            this.peakOffset += Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * this.props.speed);\r\n        else\r\n            this.peakOffset += this.count;\r\n        this.peakOffset = Math.min(this.peakOffset, this.peakMaxOffset);\r\n        this.peakOffset = Math.max(this.peakOffset, this.peakMinOffset);\r\n\r\n        if (!this.isPlaying)\r\n            this.draw();\r\n\r\n        var pos = (this.peakOffset + (this.count / 2)) / (this.peakMaxOffset + (this.count / 2));\r\n        this.scrollBarRef.setHandlePosition(pos);\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged(pos);\r\n    }\r\n\r\n    prev(){\r\n        if (this.isPlaying)\r\n            this.peakOffset -= Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * this.props.speed);\r\n        else\r\n            this.peakOffset -= this.count;\r\n        this.peakOffset = Math.min(this.peakOffset, this.peakMaxOffset);\r\n        this.peakOffset = Math.max(this.peakOffset, this.peakMinOffset);\r\n\r\n        if (!this.isPlaying)\r\n            this.draw();\r\n\r\n        var pos = (this.peakOffset + (this.count / 2)) / (this.peakMaxOffset + (this.count / 2));\r\n        this.scrollBarRef.setHandlePosition(pos);\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged(pos);\r\n    }\r\n\r\n    //Play Loop\r\n    loop(){\r\n        if (!this.isPlaying)\r\n            return;\r\n        \r\n        var now = new Date().getTime();\r\n        this.deltaTime = now - this.prevTime;\r\n        this.prevTime = now;\r\n        this.update();\r\n        this.draw();\r\n        requestAnimationFrame(this.loop);\r\n    }\r\n\r\n    update (){\r\n        this.updatecount();\r\n        this.peakOffset += Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * (this.deltaTime * 0.001) * this.props.speed);\r\n\r\n        if (this.peakOffset > this.peakMaxOffset){\r\n            this.peakOffset = this.peakMaxOffset;\r\n            this.stop();\r\n        }\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged((this.peakOffset + (this.count / 2)) / this.peakMaxOffset);\r\n\r\n        if (this.scrollBarRef != null)\r\n            this.scrollBarRef.setHandlePosition((this.peakOffset + (this.count / 2)) / (this.peakMaxOffset + (this.count / 2)));\r\n    }\r\n\r\n    draw (isUpdateGrid){\r\n        if (this.peakLength < 2)\r\n            return;\r\n        \r\n        this.updatecount();\r\n            \r\n        var channelCount = this.props.channels > this.peakArray.length ? this.peakArray.length : this.props.channels;\r\n\r\n        var len = this.count < this.peakLength ? this.count : this.peakLength;\r\n        var width = this.props.width - this.textWidth;\r\n        var widthStep = width / this.count;\r\n        var currentHeight = Math.max(50, (this.props.height - this.timelineHeight - (this.props.margin * channelCount)) / channelCount); //Math.max(50, Math.min(150, (this.props.height - this.timelineHeight - (this.props.margin * channelCount)) / channelCount));\r\n        var halfHeight = currentHeight / 2;\r\n\r\n        var startX = widthStep * Math.min(this.peakOffset, 0) * -1 + this.textWidth;\r\n        var startY = 0;\r\n        var topMargin = Math.max(this.props.height - this.timelineHeight - ((currentHeight + this.props.margin) * channelCount), 0) / 2;\r\n        \r\n        this.glContext.clearColor(0.0, 0.0, 0.0, 1.0);\r\n        this.glContext.clear(this.glContext.COLOR_BUFFER_BIT);\r\n        this.glContext.viewport(0, 0, this.canvasRef.current.width, this.canvasRef.current.height);\r\n\r\n        //Draw Graphs\r\n        var currentIdx = 0;\r\n        var x = 0;\r\n        var y = 0;\r\n        \r\n        var vertices = [];\r\n        var c = 0;\r\n        var i = 0;\r\n        var drawnChannels = 0;\r\n        \r\n        for (c = 0; c < this.peakArray.length; c++){\r\n            if (!this.channelEnabled[c])\r\n                continue;\r\n            \r\n            startY = halfHeight * (drawnChannels * 2 + 1) + (this.props.margin * drawnChannels) + topMargin + this.timelineHeight - this.verticalScrollPos;\r\n            \r\n            if (startY < -1 * currentHeight - this.props.margin)\r\n            {\r\n                drawnChannels++;\r\n                continue;\r\n            }\r\n            else if (startY > this.props.height)\r\n                break;\r\n                        \r\n            //Push GL Vertex\r\n            vertices.push(startX);\r\n            vertices.push((this.peakArray[c][Math.max(this.peakOffset, 0)] * halfHeight) + startY);\r\n\r\n            //Draw graph\r\n            for(i = 1; i < len + 1; i++){\r\n                currentIdx = Math.floor(Math.max(i + this.peakOffset, i));\r\n                if (currentIdx > this.peakArray[c].length)\r\n                    continue;\r\n\r\n                x = Math.floor((widthStep * i) + startX);\r\n                y = Math.floor((this.peakArray[c][currentIdx] * halfHeight) + startY);\r\n                vertices.push(x);\r\n                vertices.push(y);\r\n                //this.canvasContext.lineTo(x, y);\r\n            }\r\n            \r\n            vertices.push(this.props.width);\r\n            vertices.push(NaN);\r\n\r\n            drawnChannels++;\r\n        }\r\n\r\n        this.glContext.enableVertexAttribArray(this.coordAttr);\r\n        this.glContext.vertexAttribPointer(this.coordAttr, 2, this.glContext.FLOAT, false, 0, 0);\r\n        this.glContext.uniform2f(this.resolutionUniform, this.canvasRef.current.width, this.canvasRef.current.height);\r\n        \r\n        // Pass the vertex data to the buffer\r\n        this.glContext.bindBuffer(this.glContext.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.glContext.bufferData(this.glContext.ARRAY_BUFFER, new Float32Array(vertices), this.glContext.STATIC_DRAW);\r\n        this.glContext.drawArrays(this.glContext.LINE_STRIP, 0, Math.floor(vertices.length / 2));\r\n    \r\n        if (isUpdateGrid)\r\n            this.drawGrid();\r\n    }\r\n\r\n    drawGrid(){\r\n        var channelCount = this.props.channels > this.peakArray.length ? this.peakArray.length : this.props.channels;\r\n\r\n        var width = this.props.width - this.textWidth;\r\n        var widthStep = width / this.count;\r\n        var currentHeight = Math.max(50, (this.props.height - this.timelineHeight - (this.props.margin * channelCount)) / channelCount); //Math.max(50, Math.min(150, (this.props.height - this.timelineHeight - (this.props.margin * channelCount)) / channelCount));\r\n        var halfHeight = currentHeight / 2;\r\n\r\n        var startX = widthStep * Math.min(this.peakOffset, 0) * -1 + this.textWidth;\r\n        var startY = 0;\r\n        var topMargin = Math.max(this.props.height - this.timelineHeight - ((currentHeight + this.props.margin) * channelCount), 0) / 2;\r\n        \r\n        var c = 0;\r\n        var drawnChannels = 0;\r\n\r\n        this.gridContext.fillStyle = 'white';\r\n        this.gridContext.clearRect(0, 0, this.props.width, this.props.height);\r\n\r\n        for (c = 0; c < this.peakArray.length; c++){\r\n            if (!this.channelEnabled[c])\r\n                continue;\r\n            \r\n            startY = halfHeight * (drawnChannels * 2 + 1) + (this.props.margin * drawnChannels) + topMargin + this.timelineHeight - this.verticalScrollPos;\r\n            \r\n            if (startY < -1 * currentHeight - this.props.margin)\r\n            {\r\n                drawnChannels++;\r\n                continue;\r\n            }\r\n            else if (startY > this.props.height)\r\n                break;\r\n            \r\n            //Draw canvas channel text\r\n            this.gridContext.fillText(this.channelNames[c], 0, startY);\r\n            this.gridContext.moveTo(startX, (this.peakArray[c][Math.max(this.peakOffset, 0)] * halfHeight) + startY);\r\n\r\n            drawnChannels++;\r\n        }\r\n\r\n        //Draw Canvas Grids\r\n        var y = this.timelineHeight;\r\n\r\n        this.gridContext.beginPath();\r\n        this.gridContext.strokeStyle = 'red';\r\n        this.gridContext.lineWidth = 0.5;\r\n        this.gridContext.moveTo(width / 2 + this.textWidth, this.timelineHeight);\r\n        this.gridContext.lineTo (width / 2 + this.textWidth, this.props.height);\r\n        for (c = 0; c < channelCount; c++){\r\n            y = c * (currentHeight + this.props.margin) + this.timelineHeight + topMargin - this.verticalScrollPos;\r\n\r\n            this.gridContext.moveTo(this.textWidth, y);\r\n            this.gridContext.lineTo(this.textWidth + width, y);\r\n            \r\n            y += currentHeight;\r\n            this.gridContext.moveTo(this.textWidth, y);\r\n            this.gridContext.lineTo(this.textWidth + width, y);\r\n        }\r\n        this.gridContext.stroke();\r\n    }\r\n\r\n    //etc\r\n    getCanvas(){\r\n        return this.canvasRef.current;\r\n    }\r\n\r\n    render(){\r\n        var style={\r\n            display: 'flex',\r\n            flexDirection: 'column',\r\n        };\r\n        var graphStyle={\r\n            display: 'flex',\r\n            zIndex: '1',\r\n            minHeight: Math.floor(this.props.height) + 'px'\r\n        };\r\n        var gridStyle={\r\n            display: 'flex',\r\n            position: 'absolute',\r\n            zIndex: '2'\r\n        };\r\n        var scrollStyle={\r\n            display: 'flex',\r\n            position: 'relative',\r\n            zIndex: '3'\r\n        };\r\n        \r\n        this.peakMaxOffset = this.peakLength - this.count / 2;\r\n        this.peakMinOffset = this.count / -2;\r\n\r\n        return (\r\n        <div style={style}>\r\n            <div style={style}>\r\n                <canvas ref={this.canvasRef} style={graphStyle} id='graphCanvas'\r\n                width={this.props.width} height={Math.floor(this.props.height)/*this.props.channels * (this.props.height + this.props.margin) + this.timelineHeight*/}/>\r\n                <canvas ref={this.gridCanvasRef} style={gridStyle} id='gridCanvas'\r\n                width={this.props.width} height={Math.floor(this.props.height)}/>\r\n            </div>\r\n            <ScrollBar ref={ref=>{this.scrollBarRef = ref;}} style={scrollStyle}\r\n            width={this.props.width} height='20'\r\n            handleWidth={this.count / (this.peakLength + this.count / 2)}\r\n            onDragStart={this.stop}\r\n            onDrag={this.setoffset}/>\r\n        </div>);\r\n    }\r\n}\r\n\r\nexport default GLGraph;"]},"metadata":{},"sourceType":"module"}