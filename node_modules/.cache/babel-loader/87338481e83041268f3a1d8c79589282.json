{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"C:\\\\Users\\\\tank6\\\\Desktop\\\\React\\\\brainwave_webviewer\\\\src\\\\pages\\\\GLGraph.js\";\nimport React from 'react';\nimport ScrollBar from './ScrollBar';\n\nclass GLGraph extends React.Component {\n  constructor(props) {\n    super(props);\n    this.canvasRef = /*#__PURE__*/React.createRef();\n    this.canvasContext = null;\n    this.scrollBarRef = null;\n    this.isPlaying = false;\n    this.count = 1000;\n    this.deltaTime = 0;\n    this.prevTime = 0;\n    this.textWidth = 100;\n    this.timelineHeight = 50;\n    this.verticalScrollPos = 0; //WebGL\n\n    this.glContext = null;\n    this.vertexBuffer = null;\n    this.shaderProgram = null;\n    this.vertexShader = null;\n    this.fragShader = null; //Bind Functions\n\n    this.loop = this.loop.bind(this);\n    this.play = this.play.bind(this);\n    this.stop = this.stop.bind(this);\n    this.setoffset = this.setoffset.bind(this);\n    this.updatecount = this.updatecount.bind(this);\n    var channelCount = props.channels;\n    this.peakArray = [];\n    this.channelEnabled = [];\n    this.channelNames = [];\n    this.peakOffset = props.count / -2;\n    this.peakMaxOffset = 0;\n    this.peakMinOffset = props.count / -2; //Create Test Samples\n\n    var c;\n    var i;\n\n    for (c = 0; c < channelCount; c++) {\n      this.peakArray.push([]);\n      this.channelEnabled.push(true);\n      this.channelNames.push(c.toString().padStart(4, '0'));\n\n      for (i = 0; i < 100000; i++) {\n        this.peakArray[c].push(0);\n      }\n    }\n\n    this.peakMaxOffset = this.peakArray[0].length - this.count / 2;\n  }\n\n  componentDidMount() {\n    var canvas = this.canvasRef.current; //this.canvasContext = canvas.getContext('2d', {alpha: false});\n    //this.canvasContext.fillStyle = 'black';\n    //this.canvasContext.lineWidth = 1;\n    //this.canvasContext.shadowBlur = 0;\n    //this.canvasContext.font = (16) + 'px malgun gothic';\n\n    try {\n      this.glContext = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\n    } catch (e) {}\n\n    if (this.glContext) {\n      this.initWebGL(this.glContext);\n    } else {\n      alert(\"Unable to initialize WebGL. Your browser may not support it.\");\n      this.glContext = null;\n    }\n  }\n\n  componentDidUpdate() {\n    this.draw();\n  }\n\n  componentWillUnmount() {\n    this.stop();\n  }\n\n  initWebGL(gl) {\n    this.vertexBuffer = gl.createBuffer();\n    var vertices = [-0.7, -0.1, 0, -0.3, 0.6, 0, -0.3, -0.3, 0, 0.2, 0.6, 0, 0.3, -0.3, 0, 0.7, 0.6, 0]; // Bind appropriate array buffer to it\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); // Pass the vertex data to the buffer\n\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW); // Unbind the buffer\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, null); //#####Shader#####\n\n    var vsCode = 'attribute vec3 coordinates;' + 'void main(void) {' + ' gl_Position = vec4(coordinates, 1.0);' + '}';\n    var fsCode = 'void main(void) {' + 'gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' + '}';\n    this.vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    this.fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(this.vertexShader, vsCode);\n    gl.shaderSource(this.fragShader, fsCode);\n    gl.compileShader(this.vertexShader);\n    gl.compileShader(this.fragShader);\n    this.shaderProgram = gl.createProgram();\n    gl.attachShader(this.shaderProgram, this.vertexShader);\n    gl.attachShader(this.shaderProgram, this.fragShader);\n    gl.linkProgram(this.shaderProgram);\n    gl.useProgram(this.shaderProgram);\n    gl.viewport(0, 0, this.canvasRef.current.width, this.canvasRef.current.height);\n    console.log('WebGL Initialized Successfully');\n  } //Play\n\n\n  play() {\n    if (this.isPlaying) return; //Rewind\n\n    if (this.peakOffset === this.peakMaxOffset) {\n      this.peakOffset = this.peakMinOffset;\n    }\n\n    this.prevTime = new Date().getTime();\n    this.isPlaying = true;\n    requestAnimationFrame(this.loop);\n    if (this.props.onPlayStateChanged !== undefined) this.props.onPlayStateChanged();\n  }\n\n  stop() {\n    if (!this.isPlaying) return;\n    this.isPlaying = false;\n    if (this.props.onPlayStateChanged !== undefined) this.props.onPlayStateChanged();\n  }\n\n  togglePlay() {\n    if (this.isPlaying) this.stop();else this.play();\n  } //Controls\n\n\n  setfile(file) {\n    this.currentFile = file; //file.getFilteredAmpData(60, 10, file.sampleRate);\n\n    if (file.notchFilterMode === 0) {\n      this.peakArray = file.getNormalizedAmpData();\n    } else {\n      var notchFreq = file.notchFilterMode === 1 ? 50 : 60;\n      this.peakArray = file.getFilteredAmpData(notchFreq, 10, file.sampleRate);\n    }\n\n    this.updatecount();\n    this.peakMaxOffset = this.peakArray[0].length - this.count / 2;\n    this.peakMinOffset = this.count / -2;\n    this.peakOffset = this.peakMinOffset;\n    var i = 0;\n    this.channelEnabled = [];\n\n    for (i = 0; i < this.peakArray.length; i++) {\n      this.channelEnabled.push(true);\n    }\n\n    var channelData = file.getChannelData();\n    this.channelNames = [];\n\n    for (i = 0; i < channelData.length; i++) {\n      this.channelNames.push(channelData[i].customName);\n    }\n\n    this.scrollBarRef.setHandlePosition(0);\n    this.draw();\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged(0);\n  }\n\n  setchannelsenabled(arr) {\n    var j = 0;\n\n    for (var i = 0; i < this.channelEnabled.length; i++) {\n      if (arr[j] === i) {\n        this.channelEnabled[i] = true;\n\n        if (j < arr.length - 1) {\n          j++;\n        }\n      } else {\n        this.channelEnabled[i] = false;\n      }\n    }\n\n    this.verticalScrollPos = 0;\n    this.draw();\n  }\n\n  setoffset(pos) {\n    this.peakOffset = Math.floor((this.peakMaxOffset + this.count / 2) * pos) - this.count / 2;\n    if (!this.isPlaying) this.draw();\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged(pos);\n  }\n\n  updatecount() {\n    if (this.currentFile === undefined) this.count = 1000;else this.count = this.currentFile.sampleRate / 1000 * this.props.timescale;\n  }\n\n  addverticalscroll(v) {\n    var maxPos = 0;\n\n    for (var i = 0; i < this.channelEnabled.length; i++) {\n      if (this.channelEnabled[i]) maxPos++;\n    }\n\n    var currentHeight = Math.max(50, Math.min(150, (this.props.height - this.timelineHeight - this.props.margin * maxPos) / maxPos));\n    maxPos = Math.max(0, (currentHeight + this.props.margin) * maxPos - (this.props.height - this.timelineHeight));\n    this.verticalScrollPos = Math.max(0, Math.min(maxPos, this.verticalScrollPos + v));\n    if (!this.isPlaying) this.draw();\n  }\n\n  next() {\n    if (this.isPlaying) this.peakOffset += Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * this.props.speed);else this.peakOffset += this.count;\n    this.peakOffset = Math.min(this.peakOffset, this.peakMaxOffset);\n    this.peakOffset = Math.max(this.peakOffset, this.peakMinOffset);\n    if (!this.isPlaying) this.draw();\n    var pos = (this.peakOffset + this.count / 2) / (this.peakMaxOffset + this.count / 2);\n    this.scrollBarRef.setHandlePosition(pos);\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged(pos);\n  }\n\n  prev() {\n    if (this.isPlaying) this.peakOffset -= Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * this.props.speed);else this.peakOffset -= this.count;\n    this.peakOffset = Math.min(this.peakOffset, this.peakMaxOffset);\n    this.peakOffset = Math.max(this.peakOffset, this.peakMinOffset);\n    if (!this.isPlaying) this.draw();\n    var pos = (this.peakOffset + this.count / 2) / (this.peakMaxOffset + this.count / 2);\n    this.scrollBarRef.setHandlePosition(pos);\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged(pos);\n  } //Play Loop\n\n\n  loop() {\n    if (!this.isPlaying) return;\n    var now = new Date().getTime();\n    this.deltaTime = now - this.prevTime;\n    this.prevTime = now;\n    this.update();\n    this.draw();\n    requestAnimationFrame(this.loop);\n  }\n\n  update() {\n    this.updatecount();\n    this.peakOffset += Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * (this.deltaTime * 0.001) * this.props.speed);\n\n    if (this.peakOffset > this.peakMaxOffset) {\n      this.peakOffset = this.peakMaxOffset;\n      this.stop();\n    }\n\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged((this.peakOffset + this.count / 2) / this.peakMaxOffset);\n    if (this.scrollBarRef != null) this.scrollBarRef.setHandlePosition((this.peakOffset + this.count / 2) / (this.peakMaxOffset + this.count / 2));\n  }\n\n  draw() {\n    if (this.peakArray[0].length < 2) return;\n    this.updatecount();\n    var channelCount = this.props.channels > this.peakArray.length ? this.peakArray.length : this.props.channels;\n    var len = this.count < this.peakArray[0].length ? this.count : this.peakArray[0].length;\n    var width = this.props.width - this.textWidth;\n    var widthStep = width / this.count;\n    var currentHeight = Math.max(50, (this.props.height - this.timelineHeight - this.props.margin * channelCount) / channelCount); //Math.max(50, Math.min(150, (this.props.height - this.timelineHeight - (this.props.margin * channelCount)) / channelCount));\n\n    var halfHeight = currentHeight / 2;\n    var startX = widthStep * Math.min(this.peakOffset, 0) * -1 + this.textWidth;\n    var startY = 0;\n    var topMargin = Math.max(this.props.height - this.timelineHeight - (currentHeight + this.props.margin) * channelCount, 0) / 2;\n    this.canvasContext.strokeStyle = this.props.strokeColor;\n    this.canvasContext.fillStyle = 'black';\n    this.canvasContext.fillRect(0, 0, width + this.textWidth, this.props.height); //Draw Graphs\n\n    var currentIdx = 0;\n    var x = 0;\n    var y = 0;\n    var i = 0;\n    this.canvasContext.fillStyle = 'white';\n    this.canvasContext.lineWidth = 1;\n    this.canvasContext.beginPath();\n    var c = 0;\n    var drawnChannels = 0;\n\n    for (c = 0; c < this.peakArray.length; c++) {\n      if (!this.channelEnabled[c]) continue;\n      startY = halfHeight * (drawnChannels * 2 + 1) + this.props.margin * drawnChannels + topMargin + this.timelineHeight - this.verticalScrollPos; //Draw channel text\n\n      this.canvasContext.fillText(this.channelNames[c], 0, startY);\n      this.canvasContext.moveTo(startX, this.peakArray[c][Math.max(this.peakOffset, 0)] * halfHeight + startY); //Draw graph\n\n      for (i = 1; i < len + 1; i++) {\n        currentIdx = Math.floor(Math.max(i + this.peakOffset, i));\n        if (currentIdx > this.peakArray[c].length) continue;\n        x = Math.floor(widthStep * i + startX);\n        y = Math.floor(this.peakArray[c][currentIdx] * halfHeight + startY);\n        this.canvasContext.lineTo(x, y);\n      }\n\n      drawnChannels++;\n    }\n\n    this.canvasContext.stroke(); //Draw Grids\n\n    this.canvasContext.beginPath();\n    this.canvasContext.strokeStyle = 'red';\n    this.canvasContext.lineWidth = 0.5;\n    this.canvasContext.moveTo(width / 2 + this.textWidth, this.timelineHeight);\n    this.canvasContext.lineTo(width / 2 + this.textWidth, this.props.height);\n\n    for (c = 0; c < channelCount; c++) {\n      this.canvasContext.moveTo(this.textWidth, c * (currentHeight + this.props.margin) + this.timelineHeight + topMargin - this.verticalScrollPos);\n      this.canvasContext.lineTo(this.textWidth + width, c * (currentHeight + this.props.margin) + this.timelineHeight + topMargin - this.verticalScrollPos);\n      this.canvasContext.moveTo(this.textWidth, c * (currentHeight + this.props.margin) + currentHeight + this.timelineHeight + topMargin - this.verticalScrollPos);\n      this.canvasContext.lineTo(this.textWidth + width, c * (currentHeight + this.props.margin) + currentHeight + this.timelineHeight + topMargin - this.verticalScrollPos);\n    }\n\n    this.canvasContext.stroke(); //Draw timeline\n\n    this.canvasContext.fillStyle = 'black';\n    this.canvasContext.fillRect(0, 0, width + this.textWidth, this.timelineHeight);\n    this.canvasContext.fillStyle = 'white';\n    var currentTime = 0;\n\n    if (this.currentFile) {\n      for (i = 0; i < len; i++) {\n        currentIdx = Math.max(i + this.peakOffset, i);\n        currentTime = currentIdx / this.currentFile.sampleRate;\n        currentTime = Math.floor(currentTime * 100) * 0.01;\n\n        if (currentIdx % Math.floor(this.currentFile.sampleRate / 10) === 0) {\n          this.canvasContext.fillText(currentTime.toString(), startX + i * widthStep, this.timelineHeight * 0.5);\n        }\n      }\n    }\n  } //etc\n\n\n  getCanvas() {\n    return this.canvasRef.current;\n  }\n\n  render() {\n    var style = {\n      display: 'flex',\n      flexDirection: 'column',\n      height: '95%'\n    };\n    this.updatecount();\n    this.peakMaxOffset = this.peakArray[0].length - this.count / 2;\n    this.peakMinOffset = this.count / -2;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: style,\n      children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: this.canvasRef,\n        style: style,\n        id: \"graphCanvas\",\n        width: this.props.width,\n        height: this.props.height\n        /*this.props.channels * (this.props.height + this.props.margin) + this.timelineHeight*/\n\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 442,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(ScrollBar, {\n        ref: ref => {\n          this.scrollBarRef = ref;\n        },\n        width: this.props.width,\n        height: \"20\",\n        handleWidth: this.count / (this.peakArray[0].length + this.count / 2),\n        onDragStart: this.stop,\n        onDrag: this.setoffset\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 444,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 441,\n      columnNumber: 9\n    }, this);\n  }\n\n}\n\nexport default GLGraph;","map":{"version":3,"sources":["C:/Users/tank6/Desktop/React/brainwave_webviewer/src/pages/GLGraph.js"],"names":["React","ScrollBar","GLGraph","Component","constructor","props","canvasRef","createRef","canvasContext","scrollBarRef","isPlaying","count","deltaTime","prevTime","textWidth","timelineHeight","verticalScrollPos","glContext","vertexBuffer","shaderProgram","vertexShader","fragShader","loop","bind","play","stop","setoffset","updatecount","channelCount","channels","peakArray","channelEnabled","channelNames","peakOffset","peakMaxOffset","peakMinOffset","c","i","push","toString","padStart","length","componentDidMount","canvas","current","getContext","e","initWebGL","alert","componentDidUpdate","draw","componentWillUnmount","gl","createBuffer","vertices","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","vsCode","fsCode","createShader","VERTEX_SHADER","FRAGMENT_SHADER","shaderSource","compileShader","createProgram","attachShader","linkProgram","useProgram","viewport","width","height","console","log","Date","getTime","requestAnimationFrame","onPlayStateChanged","undefined","togglePlay","setfile","file","currentFile","notchFilterMode","getNormalizedAmpData","notchFreq","getFilteredAmpData","sampleRate","channelData","getChannelData","customName","setHandlePosition","onOffsetChanged","setchannelsenabled","arr","j","pos","Math","floor","timescale","addverticalscroll","v","maxPos","currentHeight","max","min","margin","next","round","speed","prev","now","update","len","widthStep","halfHeight","startX","startY","topMargin","strokeStyle","strokeColor","fillStyle","fillRect","currentIdx","x","y","lineWidth","beginPath","drawnChannels","fillText","moveTo","lineTo","stroke","currentTime","getCanvas","render","style","display","flexDirection","ref"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport ScrollBar from './ScrollBar';\r\n\r\nclass GLGraph extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.canvasRef = React.createRef();\r\n        this.canvasContext = null;\r\n        this.scrollBarRef = null;\r\n        this.isPlaying = false;\r\n        this.count = 1000;\r\n        this.deltaTime = 0;\r\n        this.prevTime = 0;\r\n        this.textWidth = 100;\r\n        this.timelineHeight = 50;\r\n        this.verticalScrollPos = 0;\r\n\r\n        //WebGL\r\n        this.glContext = null;\r\n        this.vertexBuffer = null;\r\n        this.shaderProgram = null;\r\n        this.vertexShader = null;\r\n        this.fragShader = null;\r\n\r\n        //Bind Functions\r\n        this.loop = this.loop.bind(this);\r\n\r\n        this.play = this.play.bind(this);\r\n        this.stop = this.stop.bind(this);\r\n        this.setoffset = this.setoffset.bind(this);\r\n        this.updatecount = this.updatecount.bind(this);\r\n\r\n        var channelCount = props.channels;\r\n        this.peakArray = [];\r\n        this.channelEnabled = [];\r\n        this.channelNames = [];\r\n        this.peakOffset = props.count / -2;\r\n        this.peakMaxOffset = 0;\r\n        this.peakMinOffset = props.count / -2;\r\n\r\n        //Create Test Samples\r\n        var c;\r\n        var i;\r\n        for (c = 0; c < channelCount; c++){\r\n            this.peakArray.push([]);\r\n            this.channelEnabled.push(true);\r\n            this.channelNames.push(c.toString().padStart(4, '0'));\r\n\r\n            for (i = 0; i < 100000; i++){\r\n                this.peakArray[c].push(0);\r\n            }\r\n        }\r\n\r\n        this.peakMaxOffset = this.peakArray[0].length - this.count / 2;\r\n    }\r\n\r\n    componentDidMount() {\r\n        var canvas = this.canvasRef.current;\r\n\r\n        //this.canvasContext = canvas.getContext('2d', {alpha: false});\r\n        //this.canvasContext.fillStyle = 'black';\r\n        //this.canvasContext.lineWidth = 1;\r\n        //this.canvasContext.shadowBlur = 0;\r\n        //this.canvasContext.font = (16) + 'px malgun gothic';\r\n\r\n        try{\r\n            this.glContext = canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\");\r\n        }\r\n        catch (e){}\r\n\r\n        if (this.glContext){\r\n            this.initWebGL(this.glContext);\r\n        }\r\n        else{\r\n            alert(\"Unable to initialize WebGL. Your browser may not support it.\");\r\n            this.glContext = null;\r\n        }\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        this.draw();\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        this.stop();\r\n    }\r\n\r\n    initWebGL (gl){\r\n        this.vertexBuffer = gl.createBuffer();\r\n        var vertices = [\r\n            -0.7,-0.1,0,\r\n            -0.3,0.6,0,\r\n            -0.3,-0.3,0,\r\n            0.2,0.6,0,\r\n            0.3,-0.3,0,\r\n            0.7,0.6,0]\r\n            \r\n        // Bind appropriate array buffer to it\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\r\n        \r\n        // Pass the vertex data to the buffer\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n\r\n        // Unbind the buffer\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n\r\n        //#####Shader#####\r\n        var vsCode =\r\n            'attribute vec3 coordinates;' +\r\n            'void main(void) {' +\r\n               ' gl_Position = vec4(coordinates, 1.0);' +\r\n            '}';\r\n        \r\n        var fsCode =\r\n            'void main(void) {' +\r\n               'gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +\r\n            '}';\r\n\r\n        this.vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n        this.fragShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        \r\n        gl.shaderSource(this.vertexShader, vsCode);\r\n        gl.shaderSource(this.fragShader, fsCode);\r\n        gl.compileShader(this.vertexShader);\r\n        gl.compileShader(this.fragShader);\r\n\r\n        this.shaderProgram = gl.createProgram();\r\n        \r\n        gl.attachShader(this.shaderProgram, this.vertexShader);\r\n        gl.attachShader(this.shaderProgram, this.fragShader);\r\n\r\n        gl.linkProgram(this.shaderProgram);\r\n        gl.useProgram(this.shaderProgram);\r\n\r\n        gl.viewport(0, 0, this.canvasRef.current.width, this.canvasRef.current.height);\r\n\r\n        console.log('WebGL Initialized Successfully');\r\n    }\r\n\r\n    //Play\r\n    play (){\r\n        if (this.isPlaying)\r\n            return;\r\n\r\n        //Rewind\r\n        if (this.peakOffset === this.peakMaxOffset){\r\n            this.peakOffset = this.peakMinOffset;\r\n        }\r\n        \r\n        this.prevTime = new Date().getTime();\r\n        this.isPlaying = true;\r\n        requestAnimationFrame(this.loop);\r\n\r\n        if (this.props.onPlayStateChanged !== undefined)\r\n            this.props.onPlayStateChanged();\r\n    }\r\n    \r\n    stop(){\r\n        if (!this.isPlaying)\r\n            return;\r\n\r\n        this.isPlaying = false;\r\n\r\n        if (this.props.onPlayStateChanged !== undefined)\r\n            this.props.onPlayStateChanged();\r\n    }\r\n\r\n    togglePlay (){\r\n        if (this.isPlaying)\r\n            this.stop();\r\n        else\r\n            this.play();\r\n    }\r\n    \r\n    //Controls\r\n    setfile(file){\r\n        this.currentFile = file;\r\n\r\n        //file.getFilteredAmpData(60, 10, file.sampleRate);\r\n        \r\n        if (file.notchFilterMode === 0){\r\n            this.peakArray = file.getNormalizedAmpData();\r\n        }\r\n        else {\r\n            var notchFreq = file.notchFilterMode === 1 ? 50 : 60;\r\n            this.peakArray = file.getFilteredAmpData(notchFreq, 10, file.sampleRate);\r\n        }\r\n\r\n        this.updatecount();\r\n        this.peakMaxOffset = this.peakArray[0].length - this.count / 2;\r\n        this.peakMinOffset = this.count / -2;\r\n        this.peakOffset = this.peakMinOffset;\r\n        \r\n        var i = 0;\r\n        this.channelEnabled = [];\r\n        for (i = 0; i < this.peakArray.length; i++){\r\n            this.channelEnabled.push(true);\r\n        }\r\n\r\n        var channelData = file.getChannelData();\r\n        this.channelNames = [];\r\n        for (i = 0; i < channelData.length; i++){\r\n            this.channelNames.push(channelData[i].customName);\r\n        }\r\n\r\n        this.scrollBarRef.setHandlePosition(0);\r\n        this.draw();\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged(0);\r\n    }\r\n\r\n    setchannelsenabled(arr){\r\n        var j = 0;\r\n        for (var i = 0; i < this.channelEnabled.length; i++){\r\n            if (arr[j] === i){\r\n                this.channelEnabled[i] = true;\r\n                if(j < arr.length - 1){\r\n                    j++;\r\n                }\r\n            }\r\n            else{\r\n                this.channelEnabled[i] = false;\r\n            }\r\n        }\r\n\r\n        this.verticalScrollPos = 0;\r\n        this.draw();\r\n    }\r\n\r\n    setoffset(pos){\r\n        this.peakOffset = Math.floor((this.peakMaxOffset + (this.count / 2)) * pos) - (this.count / 2);\r\n        \r\n        if (!this.isPlaying)\r\n            this.draw();\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged(pos);\r\n    }\r\n\r\n    updatecount(){\r\n        if (this.currentFile === undefined)\r\n            this.count = 1000;\r\n        else\r\n            this.count = this.currentFile.sampleRate / 1000 * this.props.timescale;\r\n    }\r\n\r\n    addverticalscroll(v){\r\n        var maxPos = 0;\r\n\r\n        for (var i = 0; i < this.channelEnabled.length; i++){\r\n            if (this.channelEnabled[i])\r\n                maxPos++;\r\n        }\r\n        \r\n        var currentHeight = Math.max(50, Math.min(150, (this.props.height - this.timelineHeight - (this.props.margin * maxPos)) / maxPos));\r\n        maxPos = Math.max(0, ((currentHeight + this.props.margin) * maxPos) - (this.props.height - this.timelineHeight));\r\n\r\n        this.verticalScrollPos = Math.max(0, Math.min(maxPos, this.verticalScrollPos + v));\r\n        \r\n        if (!this.isPlaying)\r\n            this.draw();\r\n    }\r\n\r\n    next(){\r\n        if (this.isPlaying)\r\n            this.peakOffset += Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * this.props.speed);\r\n        else\r\n            this.peakOffset += this.count;\r\n        this.peakOffset = Math.min(this.peakOffset, this.peakMaxOffset);\r\n        this.peakOffset = Math.max(this.peakOffset, this.peakMinOffset);\r\n\r\n        if (!this.isPlaying)\r\n            this.draw();\r\n\r\n        var pos = (this.peakOffset + (this.count / 2)) / (this.peakMaxOffset + (this.count / 2));\r\n        this.scrollBarRef.setHandlePosition(pos);\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged(pos);\r\n    }\r\n\r\n    prev(){\r\n        if (this.isPlaying)\r\n            this.peakOffset -= Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * this.props.speed);\r\n        else\r\n            this.peakOffset -= this.count;\r\n        this.peakOffset = Math.min(this.peakOffset, this.peakMaxOffset);\r\n        this.peakOffset = Math.max(this.peakOffset, this.peakMinOffset);\r\n\r\n        if (!this.isPlaying)\r\n            this.draw();\r\n\r\n        var pos = (this.peakOffset + (this.count / 2)) / (this.peakMaxOffset + (this.count / 2));\r\n        this.scrollBarRef.setHandlePosition(pos);\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged(pos);\r\n    }\r\n\r\n    //Play Loop\r\n    loop(){\r\n        if (!this.isPlaying)\r\n            return;\r\n        \r\n        var now = new Date().getTime();\r\n        this.deltaTime = now - this.prevTime;\r\n        this.prevTime = now;\r\n        this.update();\r\n        this.draw();\r\n        requestAnimationFrame(this.loop);\r\n    }\r\n\r\n    update (){\r\n        this.updatecount();\r\n        this.peakOffset += Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * (this.deltaTime * 0.001) * this.props.speed);\r\n\r\n        if (this.peakOffset > this.peakMaxOffset){\r\n            this.peakOffset = this.peakMaxOffset;\r\n            this.stop();\r\n        }\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged((this.peakOffset + (this.count / 2)) / this.peakMaxOffset);\r\n\r\n        if (this.scrollBarRef != null)\r\n            this.scrollBarRef.setHandlePosition((this.peakOffset + (this.count / 2)) / (this.peakMaxOffset + (this.count / 2)));\r\n    }\r\n\r\n    draw (){\r\n        if (this.peakArray[0].length < 2)\r\n            return;\r\n        \r\n        this.updatecount();\r\n            \r\n        var channelCount = this.props.channels > this.peakArray.length ? this.peakArray.length : this.props.channels;\r\n\r\n        var len = this.count < this.peakArray[0].length ? this.count : this.peakArray[0].length;\r\n        var width = this.props.width - this.textWidth;\r\n        var widthStep = width / this.count;\r\n        var currentHeight = Math.max(50, (this.props.height - this.timelineHeight - (this.props.margin * channelCount)) / channelCount); //Math.max(50, Math.min(150, (this.props.height - this.timelineHeight - (this.props.margin * channelCount)) / channelCount));\r\n        var halfHeight = currentHeight / 2;\r\n\r\n        var startX = widthStep * Math.min(this.peakOffset, 0) * -1 + this.textWidth;\r\n        var startY = 0;\r\n        var topMargin = Math.max(this.props.height - this.timelineHeight - ((currentHeight + this.props.margin) * channelCount), 0) / 2;\r\n        \r\n        this.canvasContext.strokeStyle = this.props.strokeColor;\r\n        this.canvasContext.fillStyle = 'black';\r\n        this.canvasContext.fillRect(0, 0, width + this.textWidth, this.props.height);\r\n\r\n        //Draw Graphs\r\n        var currentIdx = 0;\r\n        var x = 0;\r\n        var y = 0;\r\n        var i = 0;\r\n\r\n        this.canvasContext.fillStyle = 'white';\r\n        this.canvasContext.lineWidth = 1;\r\n        this.canvasContext.beginPath();\r\n\r\n        var c = 0;\r\n        var drawnChannels = 0;\r\n        for (c = 0; c < this.peakArray.length; c++){\r\n            if (!this.channelEnabled[c])\r\n                continue;\r\n            \r\n            startY = halfHeight * (drawnChannels * 2 + 1) + (this.props.margin * drawnChannels) + topMargin + this.timelineHeight - this.verticalScrollPos;\r\n            \r\n            //Draw channel text\r\n            this.canvasContext.fillText(this.channelNames[c], 0, startY);\r\n            this.canvasContext.moveTo(startX, (this.peakArray[c][Math.max(this.peakOffset, 0)] * halfHeight) + startY);\r\n\r\n            //Draw graph\r\n            for(i = 1; i < len + 1; i++){\r\n                currentIdx = Math.floor(Math.max(i + this.peakOffset, i));\r\n                if (currentIdx > this.peakArray[c].length)\r\n                    continue;\r\n\r\n                x = Math.floor((widthStep * i) + startX);\r\n                y = Math.floor((this.peakArray[c][currentIdx] * halfHeight) + startY);\r\n                this.canvasContext.lineTo(x, y);\r\n            }\r\n\r\n            drawnChannels++;\r\n        }\r\n        this.canvasContext.stroke();\r\n        \r\n        //Draw Grids\r\n        this.canvasContext.beginPath();\r\n        this.canvasContext.strokeStyle = 'red';\r\n        this.canvasContext.lineWidth = 0.5;\r\n        this.canvasContext.moveTo(width / 2 + this.textWidth, this.timelineHeight);\r\n        this.canvasContext.lineTo (width / 2 + this.textWidth, this.props.height);\r\n        for (c = 0; c < channelCount; c++){\r\n            this.canvasContext.moveTo(this.textWidth, c * (currentHeight + this.props.margin) + this.timelineHeight + topMargin - this.verticalScrollPos);\r\n            this.canvasContext.lineTo(this.textWidth + width, c * (currentHeight + this.props.margin) + this.timelineHeight + topMargin - this.verticalScrollPos);\r\n            \r\n            this.canvasContext.moveTo(this.textWidth, c * (currentHeight + this.props.margin) + currentHeight + this.timelineHeight + topMargin - this.verticalScrollPos);\r\n            this.canvasContext.lineTo(this.textWidth + width, c * (currentHeight + this.props.margin) + currentHeight + this.timelineHeight + topMargin - this.verticalScrollPos);\r\n        }\r\n        this.canvasContext.stroke();\r\n\r\n        //Draw timeline\r\n        this.canvasContext.fillStyle = 'black';\r\n        this.canvasContext.fillRect(0, 0, width + this.textWidth, this.timelineHeight);\r\n        this.canvasContext.fillStyle = 'white';\r\n\r\n        var currentTime = 0;\r\n\r\n        if (this.currentFile){\r\n            for (i = 0; i < len; i++){\r\n                currentIdx = Math.max(i + this.peakOffset, i);\r\n                currentTime = currentIdx / this.currentFile.sampleRate;\r\n                currentTime = Math.floor(currentTime * 100) * 0.01;\r\n\r\n                if (currentIdx % Math.floor(this.currentFile.sampleRate / 10) === 0){\r\n                    this.canvasContext.fillText(currentTime.toString(), startX + (i * widthStep), this.timelineHeight * 0.5);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //etc\r\n    getCanvas(){\r\n        return this.canvasRef.current;\r\n    }\r\n\r\n    render(){\r\n        var style={\r\n            display: 'flex',\r\n            flexDirection: 'column',\r\n            height: '95%'\r\n        };\r\n        \r\n        this.updatecount();\r\n        this.peakMaxOffset = this.peakArray[0].length - this.count / 2;\r\n        this.peakMinOffset = this.count / -2;\r\n\r\n        return (\r\n        <div style={style}>\r\n            <canvas ref={this.canvasRef} style={style} id='graphCanvas'\r\n            width={this.props.width} height={this.props.height/*this.props.channels * (this.props.height + this.props.margin) + this.timelineHeight*/}/>\r\n            <ScrollBar ref={ref=>{this.scrollBarRef = ref;}}\r\n            width={this.props.width} height='20'\r\n            handleWidth={this.count / (this.peakArray[0].length + this.count / 2)}\r\n            onDragStart={this.stop}\r\n            onDrag={this.setoffset}/>\r\n        </div>);\r\n    }\r\n}\r\n\r\nexport default GLGraph;"]},"metadata":{},"sourceType":"module"}