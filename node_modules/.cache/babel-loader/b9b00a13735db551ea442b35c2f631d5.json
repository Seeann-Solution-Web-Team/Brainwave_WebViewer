{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"C:\\\\Users\\\\tank6\\\\Desktop\\\\React\\\\brainwave_webviewer\\\\src\\\\pages\\\\GLGraph.js\";\nimport React from 'react';\nimport ScrollBar from './ScrollBar';\n\nclass GLGraph extends React.Component {\n  constructor(props) {\n    super(props);\n    this.canvasRef = /*#__PURE__*/React.createRef();\n    this.gridCanvasRef = /*#__PURE__*/React.createRef();\n    this.gridContext = null;\n    this.scrollBarRef = null;\n    this.count = 1000;\n    this.compressionRate = 5;\n    this.deltaTime = 0;\n    this.prevTime = 0;\n    this.textWidth = 100;\n    this.timelineHeight = 50; //Controls\n\n    this.isPlaying = false;\n    this.isDragging = false;\n    this.prevMouseYPos = 0;\n    this.verticalScrollPos = 0; //WebGL\n\n    this.bufferCanvas = null;\n    this.glContext = null;\n    this.viewContext = null;\n    this.vertexBuffer = null;\n    this.shaderProgram = null;\n    this.vertexShader = null;\n    this.fragShader = null;\n    this.coordAttr = null;\n    this.resolutionUniform = null; //Graph data\n\n    var channelCount = props.channels;\n    this.originPeakArray = [];\n    this.compressedPeakArray = [];\n    this.currentCompressionRate = 1;\n    this.currentPeakArray = [];\n    this.peakLength = 0;\n    this.channelEnabled = [];\n    this.channelNames = [];\n    this.peakOffset = props.count / -2;\n    this.peakPosition = 0; //Create Empty Samples\n\n    var c;\n    var i;\n\n    for (c = 0; c < channelCount; c++) {\n      this.originPeakArray.push([]);\n      this.channelEnabled.push(true);\n      this.channelNames.push(c.toString().padStart(4, '0'));\n\n      for (i = 0; i < 100000; i++) {\n        this.originPeakArray[c].push(0);\n      }\n    }\n\n    this.currentPeakArray = this.originPeakArray;\n    this.peakLength = 100000; //Bind Functions\n\n    this.loop = this.loop.bind(this);\n    this.play = this.play.bind(this);\n    this.stop = this.stop.bind(this);\n    this.setoffset = this.setoffset.bind(this);\n    this.updatecount = this.updatecount.bind(this);\n    this.resizebuffer = this.resizebuffer.bind(this);\n    this.onwheel = this.onwheel.bind(this);\n    this.ondragstart = this.ondragstart.bind(this);\n    this.ondrag = this.ondrag.bind(this);\n    this.ondragover = this.ondragover.bind(this);\n  }\n\n  componentDidMount() {\n    //Add Event\n    var c = document.getElementById(\"gridCanvas\");\n    c.addEventListener(\"touchstart\", this.touchHandler, true);\n    c.addEventListener(\"touchmove\", this.touchHandler, true);\n    c.addEventListener(\"touchend\", this.touchHandler, true);\n    c.addEventListener(\"touchcancel\", this.touchHandler, true);\n    c.addEventListener(\"wheel\", this.onwheel);\n    c.addEventListener(\"mousedown\", this.ondragstart);\n    c.addEventListener(\"mousemove\", this.ondrag);\n    c.addEventListener(\"mouseup\", this.ondragover); //Initialize Renderer\n    //Grid\n\n    this.gridContext = this.gridCanvasRef.current.getContext('2d');\n    this.gridContext.fillStyle = 'black';\n    this.gridContext.lineWidth = 1;\n    this.gridContext.shadowBlur = 0;\n    this.gridContext.font = 16 + 'px malgun gothic'; //WebGL\n\n    this.viewContext = this.canvasRef.current.getContext('2d', {\n      alpha: false\n    });\n    this.bufferCanvas = document.createElement('canvas');\n\n    try {\n      this.glContext = this.bufferCanvas.getContext(\"webgl\", {\n        preserveDrawingBuffer: true\n      }) || this.bufferCanvas.getContext(\"experimental-webgl\", {\n        preserveDrawingBuffer: true\n      });\n    } catch (e) {}\n\n    if (this.glContext) {\n      this.initWebGL(this.glContext);\n    } else {\n      alert(\"Unable to initialize WebGL. Your browser may not support it.\");\n      this.glContext = null;\n    }\n\n    this.draw(true);\n  }\n\n  componentWillUnmount() {\n    var c = document.getElementById(\"gridCanvas\");\n    c.removeEventListener(\"touchstart\", this.touchHandler, true);\n    c.removeEventListener(\"touchmove\", this.touchHandler, true);\n    c.removeEventListener(\"touchend\", this.touchHandler, true);\n    c.removeEventListener(\"touchcancel\", this.touchHandler, true);\n    c.removeEventListener(\"wheel\", this.onwheel);\n    c.removeEventListener(\"mousedown\", this.ondragstart);\n    c.removeEventListener(\"mousemove\", this.ondrag);\n    c.removeEventListener(\"mouseup\", this.ondragover);\n    this.stop();\n  }\n\n  componentDidUpdate(prevProps) {\n    //Use Compressed Array\n    if (this.props.timescale !== prevProps.timescale) {\n      if (this.props.timescale > 4000) {\n        this.currentPeakArray = this.compressedPeakArray;\n        this.currentCompressionRate = this.compressionRate;\n      } else {\n        this.currentPeakArray = this.originPeakArray;\n        this.currentCompressionRate = 1;\n      }\n\n      this.updatecount();\n      this.peakLength = this.currentPeakArray[0].length;\n    }\n\n    this.draw(true);\n  }\n\n  initWebGL(gl) {\n    //#####Set Buffer Size#####\n    this.resizebuffer(); //#####Vertex Buffer#####\n\n    this.vertexBuffer = gl.createBuffer(); //#####Shader#####\n\n    var vsCode = 'attribute vec2 coordinates;' + 'uniform vec2 u_resolution;' + 'void main(void) {' + 'vec2 zeroToOne = coordinates / u_resolution;' + 'vec2 zeroToTwo = zeroToOne * 2.0;' + 'vec2 clipSpace = zeroToTwo - 1.0;' + 'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);' + '}';\n    var fsCode = 'void main(void) {' + 'gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);' + '}';\n    this.vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    this.fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(this.vertexShader, vsCode);\n    gl.compileShader(this.vertexShader);\n    gl.shaderSource(this.fragShader, fsCode);\n    gl.compileShader(this.fragShader);\n    var compiled = gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS);\n    console.log('Shader compiled successfully: ' + compiled);\n    var compilationLog = gl.getShaderInfoLog(this.vertexShader);\n    console.log('Shader compiler log: ' + compilationLog); //Create shader program\n\n    this.shaderProgram = gl.createProgram();\n    gl.attachShader(this.shaderProgram, this.vertexShader);\n    gl.attachShader(this.shaderProgram, this.fragShader);\n    gl.linkProgram(this.shaderProgram);\n\n    if (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {\n      var info = gl.getProgramInfoLog(this.shaderProgram);\n      alert('Could not compile WebGL program. \\n\\n' + info);\n    }\n\n    this.coordAttr = gl.getAttribLocation(this.shaderProgram, 'coordinates');\n    this.resolutionUniform = gl.getUniformLocation(this.shaderProgram, \"u_resolution\");\n    this.glContext.useProgram(this.shaderProgram);\n    console.log('WebGL Initialized Successfully');\n  } //Play\n\n\n  play() {\n    if (this.isPlaying) return; //Rewind\n\n    if (this.peakPosition === this.peakLength) {\n      this.peakPosition = 0;\n      this.clearBuffer();\n    }\n\n    this.prevTime = new Date().getTime();\n    this.isPlaying = true;\n    this.drawGrid();\n    requestAnimationFrame(this.loop);\n    if (this.props.onPlayStateChanged !== undefined) this.props.onPlayStateChanged();\n  }\n\n  stop() {\n    if (!this.isPlaying) return;\n    this.isPlaying = false;\n    if (this.props.onPlayStateChanged !== undefined) this.props.onPlayStateChanged();\n  }\n\n  togglePlay() {\n    if (this.isPlaying) this.stop();else this.play();\n  } //Controls\n\n\n  setfile(file) {\n    this.currentFile = file; //file.getFilteredAmpData(60, 10, file.sampleRate);\n\n    if (file.notchFilterMode === 0) {\n      this.originPeakArray = file.getNormalizedAmpData();\n    } else {\n      var notchFreq = file.notchFilterMode === 1 ? 50 : 60;\n      this.originPeakArray = file.getFilteredAmpData(notchFreq, 10, file.sampleRate);\n    }\n\n    this.currentPeakArray = this.originPeakArray;\n    this.peakLength = this.currentFile.timestamps.length; //Compress Peaks\n\n    var c = 0;\n    var i = 0;\n    var j = 0;\n    var len = Math.ceil(this.peakLength / this.compressionRate);\n\n    for (c = 0; c < this.originPeakArray.length; c++) {\n      this.compressedPeakArray.push([]);\n\n      for (i = 0; i < len; i++) {\n        var value = 0.0;\n\n        for (j = 0; j < this.compressionRate; j++) {\n          var idx = i * this.compressionRate + j;\n          if (idx === this.originPeakArray[c].length) break;else if (Math.abs(this.originPeakArray[c][idx]) > value) {\n            value = this.originPeakArray[c][idx];\n          }\n        }\n\n        this.compressedPeakArray[c].push(value);\n      }\n    } //Update Properties\n\n\n    this.updatecount();\n    this.peakPosition = 0;\n    this.channelEnabled = [];\n\n    for (i = 0; i < this.originPeakArray.length; i++) {\n      this.channelEnabled.push(true);\n    }\n\n    var channelData = file.getChannelData();\n    this.channelNames = [];\n\n    for (i = 0; i < channelData.length; i++) {\n      this.channelNames.push(channelData[i].customName);\n    }\n\n    this.scrollBarRef.setHandlePosition(0);\n    this.resizebuffer();\n    this.draw(true);\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged(0);\n  }\n\n  setchannelsenabled(arr) {\n    var j = 0;\n\n    for (var i = 0; i < this.channelEnabled.length; i++) {\n      if (arr[j] === i) {\n        this.channelEnabled[i] = true;\n\n        if (j < arr.length - 1) {\n          j++;\n        }\n      } else {\n        this.channelEnabled[i] = false;\n      }\n    }\n\n    this.verticalScrollPos = 0;\n    this.clearBuffer();\n    this.draw(true);\n  }\n\n  setoffset(pos) {\n    this.peakPosition = Math.floor(this.peakLength * pos);\n    this.clearBuffer();\n    if (!this.isPlaying) this.draw();\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged(pos);\n  }\n\n  updatecount() {\n    if (this.currentFile === undefined) this.count = 1000;else this.count = this.currentFile.sampleRate / 1000 * (this.props.timescale / this.currentCompressionRate);\n  }\n\n  addverticalscroll(v) {\n    var maxPos = 0;\n\n    for (var i = 0; i < this.channelEnabled.length; i++) {\n      if (this.channelEnabled[i]) maxPos++;\n    }\n\n    var currentHeight = Math.max(50, Math.min(150, (this.props.height - this.timelineHeight - this.props.margin * maxPos) / maxPos));\n    maxPos = Math.max(0, (currentHeight + this.props.margin) * maxPos - (this.props.height - this.timelineHeight));\n    this.verticalScrollPos = Math.max(0, Math.min(maxPos, this.verticalScrollPos + v));\n    if (!this.isPlaying) this.draw();\n    this.drawGrid();\n  }\n\n  resizebuffer() {\n    var channelCount = Math.min(this.props.channels, this.currentPeakArray.length);\n    var currentHeight = Math.max(50, (this.props.height - this.timelineHeight - this.props.margin * channelCount) / channelCount);\n    this.glContext.canvas.width = this.props.width;\n    this.glContext.canvas.height = currentHeight * channelCount + this.props.margin * channelCount + this.timelineHeight;\n    this.glContext.width = this.glContext.canvas.width;\n    this.glContext.height = this.glContext.canvas.height;\n  }\n\n  next() {\n    if (this.isPlaying) this.peakPosition += Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * this.props.speed);else this.peakPosition += this.count;\n    this.peakPosition = Math.min(this.peakPosition, this.peakLength);\n    this.peakPosition = Math.max(this.peakPosition, 0);\n    if (!this.isPlaying) this.draw();\n    var pos = this.peakPosition / this.peakLength;\n    this.scrollBarRef.setHandlePosition(pos);\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged(pos);\n  }\n\n  prev() {\n    if (this.isPlaying) this.peakPosition -= Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * this.props.speed);else this.peakPosition -= this.count;\n    this.peakPosition = Math.min(this.peakPosition, this.peakLength);\n    this.peakPosition = Math.max(this.peakPosition, 0);\n    if (!this.isPlaying) this.draw();\n    var pos = this.peakPosition / this.peakLength;\n    this.scrollBarRef.setHandlePosition(pos);\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged(pos);\n  }\n\n  clearBuffer() {\n    this.glContext.clearColor(0.0, 0.0, 0.0, 1.0);\n    this.glContext.clear(this.glContext.COLOR_BUFFER_BIT);\n  } //Input Events\n\n\n  onwheel(e) {\n    this.addverticalscroll(e.deltaY);\n  }\n\n  ondragstart(e) {\n    this.isDragging = true;\n    this.prevMouseYPos = e.clientY;\n  }\n\n  ondrag(e) {\n    if (!this.isDragging) return;\n    this.addverticalscroll(this.prevMouseYPos - e.clientY);\n    this.prevMouseYPos = e.clientY;\n  }\n\n  ondragover(e) {\n    this.isDragging = false;\n  } //Touch event to mouse event\n\n\n  touchHandler(event) {\n    var touches = event.changedTouches;\n    var first = touches[0];\n    var type = \"\";\n\n    switch (event.type) {\n      case \"touchstart\":\n        type = \"mousedown\";\n        break;\n\n      case \"touchmove\":\n        type = \"mousemove\";\n        break;\n\n      case \"touchend\":\n        type = \"mouseup\";\n        break;\n\n      default:\n        return;\n    }\n\n    var simulatedEvent = document.createEvent(\"MouseEvent\");\n    simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0\n    /*left*/\n    , null);\n    first.target.dispatchEvent(simulatedEvent);\n    event.preventDefault();\n  } //Play Loop\n\n\n  loop() {\n    if (!this.isPlaying) return;\n    var now = new Date().getTime();\n    this.deltaTime = now - this.prevTime;\n    this.prevTime = now;\n    this.update();\n    this.draw();\n    requestAnimationFrame(this.loop);\n  }\n\n  update() {\n    this.updatecount();\n    this.peakPosition += Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * (this.deltaTime * 0.001) * this.props.speed / this.currentCompressionRate);\n\n    if (this.peakPosition > this.peakLength) {\n      this.peakPosition = this.peakLength;\n      this.stop();\n    }\n\n    if (this.props.onOffsetChanged !== undefined) this.props.onOffsetChanged(this.peakPosition / this.peakLength);\n    if (this.scrollBarRef != null) this.scrollBarRef.setHandlePosition(this.peakPosition / this.peakLength);\n  }\n\n  draw(isUpdateGrid) {\n    if (this.peakLength < 2) return;\n    this.updatecount();\n    var channelCount = this.props.channels > this.currentPeakArray.length ? this.currentPeakArray.length : this.props.channels;\n    var len = this.peakPosition % this.count;\n    var width = this.props.width - this.textWidth;\n    var widthStep = width / this.count;\n    var currentHeight = Math.max(50, (this.glContext.height - this.timelineHeight - this.props.margin * channelCount) / channelCount); //Math.max(50, Math.min(150, (this.props.height - this.timelineHeight - (this.props.margin * channelCount)) / channelCount));\n\n    var halfHeight = currentHeight / 2;\n    var startY = 0;\n    var topMargin = Math.max(this.glContext.height - this.timelineHeight - (currentHeight + this.props.margin) * channelCount, 0) / 2;\n    var clearWidth = Math.floor(this.count * (this.deltaTime * 0.001)); //Clear Rect\n\n    this.glContext.enable(this.glContext.SCISSOR_TEST);\n    this.glContext.scissor(this.textWidth + widthStep * len - widthStep * clearWidth, 0, widthStep * clearWidth, this.glContext.height);\n    this.glContext.clearColor(0.0, 0.0, 0.0, 1.0);\n    this.glContext.clear(this.glContext.COLOR_BUFFER_BIT);\n    this.glContext.disable(this.glContext.SCISSOR_TEST); //Clear Entire Canvas\n\n    /*\r\n    this.glContext.clearColor(0.0, 0.0, 0.0, 1.0);\r\n    this.glContext.clear(this.glContext.COLOR_BUFFER_BIT);\r\n    */\n\n    this.glContext.viewport(0, 0, this.glContext.width, this.glContext.height); //Draw Graphs\n\n    var currentIdx = 0;\n    var x = 0;\n    var y = 0;\n    var vertices = [];\n    var tempArray = [];\n    var c = 0;\n    var i = 0;\n    var drawnChannels = 0;\n\n    for (c = 0; c < this.currentPeakArray.length; c++) {\n      if (!this.channelEnabled[c]) continue;\n      startY = halfHeight * (drawnChannels * 2 + 1) + this.props.margin * drawnChannels + topMargin + this.timelineHeight; //Draw graph\n\n      for (i = 0; i < clearWidth; i++) {\n        currentIdx = Math.floor(this.peakPosition - clearWidth + i);\n        if (currentIdx > this.currentPeakArray[c].length || len - clearWidth + i < 0) continue;\n        x = Math.floor(widthStep * (len - clearWidth + i) + this.textWidth);\n        y = Math.floor(this.currentPeakArray[c][currentIdx] * halfHeight + startY);\n        tempArray.push(x);\n        tempArray.push(y);\n      } //Filter\n\n\n      if (this.currentFile) this.notchFilter(tempArray, 50, 10, this.currentFile.sampleRate); //Copy to vertex array\n\n      for (i = 0; i < tempArray.length; i++) {\n        vertices.push(tempArray[i]);\n      }\n\n      tempArray = [];\n      vertices.push(this.props.width);\n      vertices.push(NaN);\n      drawnChannels++;\n    } //Set shader attributes\n\n\n    this.glContext.enableVertexAttribArray(this.coordAttr);\n    this.glContext.vertexAttribPointer(this.coordAttr, 2, this.glContext.FLOAT, false, 0, 0);\n    this.glContext.uniform2f(this.resolutionUniform, this.glContext.width, this.glContext.height); // Pass the vertex data to the buffer\n\n    this.glContext.bindBuffer(this.glContext.ARRAY_BUFFER, this.vertexBuffer);\n    this.glContext.bufferData(this.glContext.ARRAY_BUFFER, new Float32Array(vertices), this.glContext.STATIC_DRAW);\n    this.glContext.drawArrays(this.glContext.LINE_STRIP, 0, Math.floor(vertices.length / 2)); //Copy back buffer to front buffer\n\n    this.viewContext.fillStyle = 'black';\n    this.viewContext.fillRect(0, 0, this.props.width, this.props.height);\n    this.viewContext.drawImage(this.bufferCanvas, 0, -this.verticalScrollPos);\n    if (isUpdateGrid) this.drawGrid();\n  }\n\n  drawGrid() {\n    var channelCount = this.props.channels > this.currentPeakArray.length ? this.currentPeakArray.length : this.props.channels;\n    var width = this.props.width - this.textWidth;\n    var currentHeight = Math.max(50, (this.props.height - this.timelineHeight - this.props.margin * channelCount) / channelCount);\n    var halfHeight = currentHeight / 2;\n    var startY = 0;\n    var topMargin = Math.max(this.props.height - this.timelineHeight - (currentHeight + this.props.margin) * channelCount, 0) / 2;\n    var c = 0;\n    var drawnChannels = 0;\n    this.gridContext.fillStyle = 'white';\n    this.gridContext.clearRect(0, 0, this.props.width, this.props.height);\n\n    for (c = 0; c < this.currentPeakArray.length; c++) {\n      if (!this.channelEnabled[c]) continue;\n      startY = halfHeight * (drawnChannels * 2 + 1) + this.props.margin * drawnChannels + topMargin + this.timelineHeight - this.verticalScrollPos;\n\n      if (startY < -1 * currentHeight - this.props.margin) {\n        drawnChannels++;\n        continue;\n      } else if (startY > this.props.height) break; //Draw canvas channel text\n\n\n      this.gridContext.fillText(this.channelNames[c], 0, startY); //this.gridContext.moveTo(startX, (this.currentPeakArray[c][Math.max(this.peakOffset, 0)] * halfHeight) + startY);\n\n      drawnChannels++;\n    } //Draw Canvas Grids\n\n\n    var y = this.timelineHeight;\n    this.gridContext.beginPath();\n    this.gridContext.strokeStyle = 'red';\n    this.gridContext.lineWidth = 0.5;\n\n    for (c = 0; c < channelCount; c++) {\n      y = c * (currentHeight + this.props.margin) + this.timelineHeight + topMargin - this.verticalScrollPos;\n      this.gridContext.moveTo(this.textWidth, y);\n      this.gridContext.lineTo(this.textWidth + width, y);\n      y += currentHeight;\n      this.gridContext.moveTo(this.textWidth, y);\n      this.gridContext.lineTo(this.textWidth + width, y);\n    }\n\n    this.gridContext.stroke();\n  } //etc\n\n\n  getCanvas() {\n    return this.canvasRef.current;\n  }\n\n  notchFilter(arr, notchFreq, bandwidth, sampleFreq) {\n    var filtered = []; // Calculate biquad IIR filter coefficients.\n\n    var d = Math.exp(-Math.PI * bandwidth / sampleFreq);\n    var a1 = -(1.0 + d * d) * Math.cos(2.0 * Math.PI * notchFreq / sampleFreq);\n    var a2 = d * d;\n    var b0 = (1 + d * d) / 2.0;\n    var b1 = a1;\n    var b2 = b0;\n    var i = 2; //Filter\n\n    var value = 0;\n    filtered.push(arr[0]);\n    filtered.push(arr[1]);\n\n    for (i = 2; i < arr.length; i++) {\n      value = b0 * arr[i] + b1 * arr[i - 1] + b2 * arr[i - 2] - a1 * filtered[i - 1] - a2 * filtered[i - 2];\n      filtered.push(value);\n    } //Copy to arr\n\n\n    for (i = 0; i < arr.length; i++) {\n      arr[i] = filtered[i];\n    }\n  }\n\n  render() {\n    var style = {\n      display: 'flex',\n      flexDirection: 'column'\n    };\n    var graphStyle = {\n      display: 'flex',\n      zIndex: '1',\n      minHeight: Math.floor(this.props.height) + 'px'\n    };\n    var gridStyle = {\n      display: 'flex',\n      position: 'absolute',\n      zIndex: '2'\n    };\n    var scrollStyle = {\n      display: 'flex',\n      position: 'relative',\n      zIndex: '3'\n    };\n    if (this.glContext !== null) this.resizebuffer();\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: style,\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        style: style,\n        children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n          ref: this.canvasRef,\n          style: graphStyle,\n          id: \"graphCanvas\",\n          width: this.props.width,\n          height: Math.floor(this.props.height)\n          /*this.props.channels * (this.props.height + this.props.margin) + this.timelineHeight*/\n\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 719,\n          columnNumber: 17\n        }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n          ref: this.gridCanvasRef,\n          style: gridStyle,\n          id: \"gridCanvas\",\n          width: this.props.width,\n          height: Math.floor(this.props.height)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 721,\n          columnNumber: 17\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 718,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(ScrollBar, {\n        ref: ref => {\n          this.scrollBarRef = ref;\n        },\n        style: scrollStyle,\n        width: this.props.width,\n        height: \"20\",\n        handleWidth: this.count / (this.peakLength + this.count / 2),\n        onDrag: this.setoffset\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 724,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 717,\n      columnNumber: 9\n    }, this);\n  }\n\n}\n\nexport default GLGraph;","map":{"version":3,"sources":["C:/Users/tank6/Desktop/React/brainwave_webviewer/src/pages/GLGraph.js"],"names":["React","ScrollBar","GLGraph","Component","constructor","props","canvasRef","createRef","gridCanvasRef","gridContext","scrollBarRef","count","compressionRate","deltaTime","prevTime","textWidth","timelineHeight","isPlaying","isDragging","prevMouseYPos","verticalScrollPos","bufferCanvas","glContext","viewContext","vertexBuffer","shaderProgram","vertexShader","fragShader","coordAttr","resolutionUniform","channelCount","channels","originPeakArray","compressedPeakArray","currentCompressionRate","currentPeakArray","peakLength","channelEnabled","channelNames","peakOffset","peakPosition","c","i","push","toString","padStart","loop","bind","play","stop","setoffset","updatecount","resizebuffer","onwheel","ondragstart","ondrag","ondragover","componentDidMount","document","getElementById","addEventListener","touchHandler","current","getContext","fillStyle","lineWidth","shadowBlur","font","alpha","createElement","preserveDrawingBuffer","e","initWebGL","alert","draw","componentWillUnmount","removeEventListener","componentDidUpdate","prevProps","timescale","length","gl","createBuffer","vsCode","fsCode","createShader","VERTEX_SHADER","FRAGMENT_SHADER","shaderSource","compileShader","compiled","getShaderParameter","COMPILE_STATUS","console","log","compilationLog","getShaderInfoLog","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","info","getProgramInfoLog","getAttribLocation","getUniformLocation","useProgram","clearBuffer","Date","getTime","drawGrid","requestAnimationFrame","onPlayStateChanged","undefined","togglePlay","setfile","file","currentFile","notchFilterMode","getNormalizedAmpData","notchFreq","getFilteredAmpData","sampleRate","timestamps","j","len","Math","ceil","value","idx","abs","channelData","getChannelData","customName","setHandlePosition","onOffsetChanged","setchannelsenabled","arr","pos","floor","addverticalscroll","v","maxPos","currentHeight","max","min","height","margin","canvas","width","next","round","speed","prev","clearColor","clear","COLOR_BUFFER_BIT","deltaY","clientY","event","touches","changedTouches","first","type","simulatedEvent","createEvent","initMouseEvent","window","screenX","screenY","clientX","target","dispatchEvent","preventDefault","now","update","isUpdateGrid","widthStep","halfHeight","startY","topMargin","clearWidth","enable","SCISSOR_TEST","scissor","disable","viewport","currentIdx","x","y","vertices","tempArray","drawnChannels","notchFilter","NaN","enableVertexAttribArray","vertexAttribPointer","FLOAT","uniform2f","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","drawArrays","LINE_STRIP","fillRect","drawImage","clearRect","fillText","beginPath","strokeStyle","moveTo","lineTo","stroke","getCanvas","bandwidth","sampleFreq","filtered","d","exp","PI","a1","cos","a2","b0","b1","b2","render","style","display","flexDirection","graphStyle","zIndex","minHeight","gridStyle","position","scrollStyle","ref"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport ScrollBar from './ScrollBar';\r\n\r\nclass GLGraph extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.canvasRef = React.createRef();\r\n        this.gridCanvasRef = React.createRef();\r\n        this.gridContext = null;\r\n        this.scrollBarRef = null;\r\n        this.count = 1000;\r\n        this.compressionRate = 5;\r\n        this.deltaTime = 0;\r\n        this.prevTime = 0;\r\n        this.textWidth = 100;\r\n        this.timelineHeight = 50;\r\n\r\n        //Controls\r\n        this.isPlaying = false;\r\n        this.isDragging = false;\r\n        this.prevMouseYPos = 0;\r\n        this.verticalScrollPos = 0;\r\n\r\n        //WebGL\r\n        this.bufferCanvas = null;\r\n        this.glContext = null;\r\n        this.viewContext = null;\r\n        this.vertexBuffer = null;\r\n        this.shaderProgram = null;\r\n        this.vertexShader = null;\r\n        this.fragShader = null;\r\n        this.coordAttr = null;\r\n        this.resolutionUniform = null;\r\n\r\n        //Graph data\r\n        var channelCount = props.channels;\r\n        this.originPeakArray = [];\r\n        this.compressedPeakArray = [];\r\n        this.currentCompressionRate = 1;\r\n        this.currentPeakArray = [];\r\n        this.peakLength = 0;\r\n        this.channelEnabled = [];\r\n        this.channelNames = [];\r\n        this.peakOffset = props.count / -2;\r\n        this.peakPosition = 0;\r\n\r\n        //Create Empty Samples\r\n        var c;\r\n        var i;\r\n        for (c = 0; c < channelCount; c++){\r\n            this.originPeakArray.push([]);\r\n            this.channelEnabled.push(true);\r\n            this.channelNames.push(c.toString().padStart(4, '0'));\r\n\r\n            for (i = 0; i < 100000; i++){\r\n                this.originPeakArray[c].push(0);\r\n            }\r\n        }\r\n        this.currentPeakArray = this.originPeakArray;\r\n        this.peakLength = 100000;\r\n        \r\n        //Bind Functions\r\n        this.loop = this.loop.bind(this);\r\n        this.play = this.play.bind(this);\r\n        this.stop = this.stop.bind(this);\r\n        this.setoffset = this.setoffset.bind(this);\r\n        this.updatecount = this.updatecount.bind(this);\r\n        this.resizebuffer = this.resizebuffer.bind(this);\r\n\r\n        this.onwheel = this.onwheel.bind(this);\r\n        this.ondragstart = this.ondragstart.bind(this);\r\n        this.ondrag = this.ondrag.bind(this);\r\n        this.ondragover = this.ondragover.bind(this);\r\n    }\r\n\r\n    componentDidMount() {\r\n        //Add Event\r\n        var c = document.getElementById(\"gridCanvas\");\r\n        c.addEventListener(\"touchstart\", this.touchHandler, true);\r\n        c.addEventListener(\"touchmove\", this.touchHandler, true);\r\n        c.addEventListener(\"touchend\", this.touchHandler, true);\r\n        c.addEventListener(\"touchcancel\", this.touchHandler, true);\r\n\r\n        c.addEventListener(\"wheel\", this.onwheel);\r\n        c.addEventListener(\"mousedown\", this.ondragstart);\r\n        c.addEventListener(\"mousemove\", this.ondrag);\r\n        c.addEventListener(\"mouseup\", this.ondragover);\r\n\r\n        //Initialize Renderer\r\n        //Grid\r\n        this.gridContext = this.gridCanvasRef.current.getContext('2d');\r\n        this.gridContext.fillStyle = 'black';\r\n        this.gridContext.lineWidth = 1;\r\n        this.gridContext.shadowBlur = 0;\r\n        this.gridContext.font = (16) + 'px malgun gothic';\r\n        //WebGL\r\n        this.viewContext = this.canvasRef.current.getContext('2d', {alpha: false});\r\n        this.bufferCanvas = document.createElement('canvas');\r\n        try{\r\n            this.glContext = this.bufferCanvas.getContext(\"webgl\", {preserveDrawingBuffer: true}) || this.bufferCanvas.getContext(\"experimental-webgl\", {preserveDrawingBuffer: true});\r\n        }\r\n        catch (e){}\r\n\r\n        if (this.glContext){\r\n            this.initWebGL(this.glContext);\r\n        }\r\n        else{\r\n            alert(\"Unable to initialize WebGL. Your browser may not support it.\");\r\n            this.glContext = null;\r\n        }\r\n\r\n        this.draw(true);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        var c = document.getElementById(\"gridCanvas\");\r\n        c.removeEventListener(\"touchstart\", this.touchHandler, true);\r\n        c.removeEventListener(\"touchmove\", this.touchHandler, true);\r\n        c.removeEventListener(\"touchend\", this.touchHandler, true);\r\n        c.removeEventListener(\"touchcancel\", this.touchHandler, true);\r\n\r\n        c.removeEventListener(\"wheel\", this.onwheel);\r\n        c.removeEventListener(\"mousedown\", this.ondragstart);\r\n        c.removeEventListener(\"mousemove\", this.ondrag);\r\n        c.removeEventListener(\"mouseup\", this.ondragover);\r\n        \r\n        this.stop();\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        //Use Compressed Array\r\n        if (this.props.timescale !== prevProps.timescale){\r\n            if (this.props.timescale > 4000){\r\n                this.currentPeakArray = this.compressedPeakArray;\r\n                this.currentCompressionRate = this.compressionRate;\r\n            }\r\n            else{\r\n                this.currentPeakArray = this.originPeakArray;\r\n                this.currentCompressionRate = 1;\r\n            }\r\n\r\n            this.updatecount();\r\n            this.peakLength = this.currentPeakArray[0].length;\r\n        }\r\n\r\n        this.draw(true);\r\n    }\r\n\r\n    initWebGL (gl){\r\n        //#####Set Buffer Size#####\r\n        this.resizebuffer();\r\n        \r\n        //#####Vertex Buffer#####\r\n        this.vertexBuffer = gl.createBuffer();\r\n\r\n        //#####Shader#####\r\n        var vsCode =\r\n            'attribute vec2 coordinates;' +\r\n            'uniform vec2 u_resolution;' +\r\n            'void main(void) {' +\r\n                'vec2 zeroToOne = coordinates / u_resolution;' +\r\n                'vec2 zeroToTwo = zeroToOne * 2.0;' +\r\n                'vec2 clipSpace = zeroToTwo - 1.0;' +\r\n                'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);' + \r\n            '}';\r\n        \r\n        var fsCode =\r\n            'void main(void) {' +\r\n               'gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);' +\r\n            '}';\r\n\r\n        this.vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n        this.fragShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        \r\n        gl.shaderSource(this.vertexShader, vsCode);\r\n        gl.compileShader(this.vertexShader);\r\n        gl.shaderSource(this.fragShader, fsCode);\r\n        gl.compileShader(this.fragShader);\r\n\r\n        var compiled = gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS);\r\n        console.log('Shader compiled successfully: ' + compiled);\r\n        var compilationLog = gl.getShaderInfoLog(this.vertexShader);\r\n        console.log('Shader compiler log: ' + compilationLog);\r\n        \r\n        //Create shader program\r\n        this.shaderProgram = gl.createProgram();\r\n        \r\n        gl.attachShader(this.shaderProgram, this.vertexShader);\r\n        gl.attachShader(this.shaderProgram, this.fragShader);\r\n\r\n        gl.linkProgram(this.shaderProgram);\r\n\r\n        if ( !gl.getProgramParameter( this.shaderProgram, gl.LINK_STATUS) ) {\r\n            var info = gl.getProgramInfoLog(this.shaderProgram);\r\n            alert('Could not compile WebGL program. \\n\\n' + info);\r\n        }\r\n\r\n        this.coordAttr = gl.getAttribLocation(this.shaderProgram, 'coordinates');\r\n        this.resolutionUniform = gl.getUniformLocation(this.shaderProgram, \"u_resolution\");\r\n        this.glContext.useProgram(this.shaderProgram);\r\n\r\n        console.log('WebGL Initialized Successfully');\r\n    }\r\n\r\n    //Play\r\n    play (){\r\n        if (this.isPlaying)\r\n            return;\r\n\r\n        //Rewind\r\n        if (this.peakPosition === this.peakLength){\r\n            this.peakPosition = 0;\r\n            this.clearBuffer();\r\n        }\r\n        \r\n        this.prevTime = new Date().getTime();\r\n        this.isPlaying = true;\r\n        this.drawGrid();\r\n        requestAnimationFrame(this.loop);\r\n\r\n        if (this.props.onPlayStateChanged !== undefined)\r\n            this.props.onPlayStateChanged();\r\n    }\r\n    \r\n    stop(){\r\n        if (!this.isPlaying)\r\n            return;\r\n\r\n        this.isPlaying = false;\r\n\r\n        if (this.props.onPlayStateChanged !== undefined)\r\n            this.props.onPlayStateChanged();\r\n    }\r\n\r\n    togglePlay (){\r\n        if (this.isPlaying)\r\n            this.stop();\r\n        else\r\n            this.play();\r\n    }\r\n    \r\n    //Controls\r\n    setfile(file){\r\n        this.currentFile = file;\r\n\r\n        //file.getFilteredAmpData(60, 10, file.sampleRate);\r\n        \r\n        if (file.notchFilterMode === 0){\r\n            this.originPeakArray = file.getNormalizedAmpData();\r\n        }\r\n        else {\r\n            var notchFreq = file.notchFilterMode === 1 ? 50 : 60;\r\n            this.originPeakArray = file.getFilteredAmpData(notchFreq, 10, file.sampleRate);\r\n        }\r\n        this.currentPeakArray = this.originPeakArray;\r\n        this.peakLength = this.currentFile.timestamps.length;\r\n\r\n        //Compress Peaks\r\n        var c = 0;\r\n        var i = 0;\r\n        var j = 0;\r\n\r\n        var len = Math.ceil(this.peakLength / this.compressionRate);\r\n        for (c = 0; c < this.originPeakArray.length; c++){\r\n            this.compressedPeakArray.push([]);\r\n\r\n            for (i = 0; i < len; i++){\r\n                var value = 0.0;\r\n\r\n                for (j = 0; j < this.compressionRate; j++){\r\n                    var idx = i * this.compressionRate + j;\r\n\r\n                    if (idx === this.originPeakArray[c].length)\r\n                        break;\r\n                    else if (Math.abs(this.originPeakArray[c][idx]) > value){\r\n                        value = this.originPeakArray[c][idx];\r\n                    }\r\n                }\r\n                \r\n                this.compressedPeakArray[c].push(value);\r\n            }\r\n        }\r\n\r\n        //Update Properties\r\n        this.updatecount();\r\n        this.peakPosition = 0;\r\n        \r\n        this.channelEnabled = [];\r\n        for (i = 0; i < this.originPeakArray.length; i++){\r\n            this.channelEnabled.push(true);\r\n        }\r\n\r\n        var channelData = file.getChannelData();\r\n        this.channelNames = [];\r\n        for (i = 0; i < channelData.length; i++){\r\n            this.channelNames.push(channelData[i].customName);\r\n        }\r\n\r\n        this.scrollBarRef.setHandlePosition(0);\r\n        this.resizebuffer();\r\n        this.draw(true);\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged(0);\r\n    }\r\n\r\n    setchannelsenabled(arr){\r\n        var j = 0;\r\n        for (var i = 0; i < this.channelEnabled.length; i++){\r\n            if (arr[j] === i){\r\n                this.channelEnabled[i] = true;\r\n                if(j < arr.length - 1){\r\n                    j++;\r\n                }\r\n            }\r\n            else{\r\n                this.channelEnabled[i] = false;\r\n            }\r\n        }\r\n\r\n        this.verticalScrollPos = 0;\r\n        this.clearBuffer();\r\n        this.draw(true);\r\n    }\r\n\r\n    setoffset(pos){\r\n        this.peakPosition = Math.floor(this.peakLength * pos);\r\n        this.clearBuffer();\r\n\r\n        if (!this.isPlaying)\r\n            this.draw();\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged(pos);\r\n    }\r\n\r\n    updatecount(){\r\n        if (this.currentFile === undefined)\r\n            this.count = 1000;\r\n        else\r\n            this.count = this.currentFile.sampleRate / 1000 * (this.props.timescale / this.currentCompressionRate);\r\n    }\r\n\r\n    addverticalscroll(v){\r\n        var maxPos = 0;\r\n\r\n        for (var i = 0; i < this.channelEnabled.length; i++){\r\n            if (this.channelEnabled[i])\r\n                maxPos++;\r\n        }\r\n        \r\n        var currentHeight = Math.max(50, Math.min(150, (this.props.height - this.timelineHeight - (this.props.margin * maxPos)) / maxPos));\r\n        maxPos = Math.max(0, ((currentHeight + this.props.margin) * maxPos) - (this.props.height - this.timelineHeight));\r\n\r\n        this.verticalScrollPos = Math.max(0, Math.min(maxPos, this.verticalScrollPos + v));\r\n        \r\n        if (!this.isPlaying)\r\n            this.draw();\r\n            \r\n        this.drawGrid();\r\n    }\r\n\r\n    resizebuffer(){\r\n        var channelCount =  Math.min(this.props.channels, this.currentPeakArray.length);\r\n        var currentHeight = Math.max(50, (this.props.height - this.timelineHeight - (this.props.margin * channelCount)) / channelCount);\r\n        this.glContext.canvas.width = this.props.width;\r\n        this.glContext.canvas.height = (currentHeight * channelCount) + (this.props.margin * channelCount) + this.timelineHeight;\r\n        this.glContext.width = this.glContext.canvas.width;\r\n        this.glContext.height = this.glContext.canvas.height;\r\n    }\r\n\r\n    next(){\r\n        if (this.isPlaying)\r\n            this.peakPosition += Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * this.props.speed);\r\n        else\r\n            this.peakPosition += this.count;\r\n        this.peakPosition = Math.min(this.peakPosition, this.peakLength);\r\n        this.peakPosition = Math.max(this.peakPosition, 0);\r\n\r\n        if (!this.isPlaying)\r\n            this.draw();\r\n\r\n        var pos = this.peakPosition / this.peakLength;\r\n        this.scrollBarRef.setHandlePosition(pos);\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged(pos);\r\n    }\r\n\r\n    prev(){\r\n        if (this.isPlaying)\r\n            this.peakPosition -= Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * this.props.speed);\r\n        else\r\n            this.peakPosition -= this.count;\r\n        this.peakPosition = Math.min(this.peakPosition, this.peakLength);\r\n        this.peakPosition = Math.max(this.peakPosition, 0);\r\n\r\n        if (!this.isPlaying)\r\n            this.draw();\r\n\r\n        var pos = this.peakPosition / this.peakLength;\r\n        this.scrollBarRef.setHandlePosition(pos);\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged(pos);\r\n    }\r\n\r\n    clearBuffer(){\r\n        this.glContext.clearColor(0.0, 0.0, 0.0, 1.0);\r\n        this.glContext.clear(this.glContext.COLOR_BUFFER_BIT);\r\n    }\r\n\r\n    //Input Events\r\n    onwheel(e){\r\n        this.addverticalscroll(e.deltaY);\r\n    }\r\n\r\n    ondragstart(e){\r\n        this.isDragging = true;\r\n        this.prevMouseYPos = e.clientY;\r\n    }\r\n\r\n    ondrag(e){\r\n        if (!this.isDragging)\r\n            return;\r\n\r\n        this.addverticalscroll(this.prevMouseYPos - e.clientY);\r\n        this.prevMouseYPos = e.clientY;\r\n    }\r\n\r\n    ondragover(e){\r\n        this.isDragging = false;\r\n    }\r\n\r\n    //Touch event to mouse event\r\n    touchHandler(event)\r\n    {\r\n        var touches = event.changedTouches;\r\n        var first = touches[0];\r\n        var type = \"\";\r\n        \r\n        switch(event.type)\r\n        {\r\n            case \"touchstart\": \r\n                type = \"mousedown\"; \r\n                break;\r\n            case \"touchmove\": \r\n                type=\"mousemove\"; \r\n                break;       \r\n            case \"touchend\":   \r\n                type=\"mouseup\"; \r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n        var simulatedEvent = document.createEvent(\"MouseEvent\");\r\n        simulatedEvent.initMouseEvent(type, true, true, window, 1,\r\n                                first.screenX, first.screenY,\r\n                                first.clientX, first.clientY, false,\r\n                                false, false, false, 0/*left*/, null);\r\n    \r\n        first.target.dispatchEvent(simulatedEvent);\r\n        event.preventDefault();\r\n    }\r\n\r\n    //Play Loop\r\n    loop(){\r\n        if (!this.isPlaying)\r\n            return;\r\n        \r\n        var now = new Date().getTime();\r\n        this.deltaTime = now - this.prevTime;\r\n        this.prevTime = now;\r\n        this.update();\r\n        this.draw();\r\n        requestAnimationFrame(this.loop);\r\n    }\r\n\r\n    update (){\r\n        this.updatecount();\r\n        this.peakPosition += Math.round((this.currentFile === undefined ? 100 : this.currentFile.sampleRate) * (this.deltaTime * 0.001) * this.props.speed / this.currentCompressionRate);\r\n\r\n        if (this.peakPosition > this.peakLength){\r\n            this.peakPosition = this.peakLength;\r\n            this.stop();\r\n        }\r\n\r\n        if (this.props.onOffsetChanged !== undefined)\r\n            this.props.onOffsetChanged(this.peakPosition / this.peakLength);\r\n\r\n        if (this.scrollBarRef != null)\r\n            this.scrollBarRef.setHandlePosition(this.peakPosition / this.peakLength);\r\n    }\r\n\r\n    draw (isUpdateGrid){\r\n        if (this.peakLength < 2)\r\n            return;\r\n        \r\n        this.updatecount();\r\n            \r\n        var channelCount = this.props.channels > this.currentPeakArray.length ? this.currentPeakArray.length : this.props.channels;\r\n\r\n        var len = this.peakPosition % this.count;\r\n        var width = this.props.width - this.textWidth;\r\n        var widthStep = width / this.count;\r\n        var currentHeight = Math.max(50, (this.glContext.height - this.timelineHeight - (this.props.margin * channelCount)) / channelCount); //Math.max(50, Math.min(150, (this.props.height - this.timelineHeight - (this.props.margin * channelCount)) / channelCount));\r\n        var halfHeight = currentHeight / 2;\r\n\r\n        var startY = 0;\r\n        var topMargin = Math.max(this.glContext.height - this.timelineHeight - ((currentHeight + this.props.margin) * channelCount), 0) / 2;\r\n        var clearWidth = Math.floor(this.count  * (this.deltaTime * 0.001));\r\n\r\n        //Clear Rect\r\n        this.glContext.enable(this.glContext.SCISSOR_TEST);\r\n        this.glContext.scissor(this.textWidth + (widthStep * len) - (widthStep * clearWidth),\r\n                            0,\r\n                            widthStep * clearWidth,\r\n                            this.glContext.height);\r\n\r\n        this.glContext.clearColor(0.0, 0.0, 0.0, 1.0);\r\n        this.glContext.clear(this.glContext.COLOR_BUFFER_BIT);\r\n        this.glContext.disable(this.glContext.SCISSOR_TEST);\r\n\r\n        //Clear Entire Canvas\r\n        /*\r\n        this.glContext.clearColor(0.0, 0.0, 0.0, 1.0);\r\n        this.glContext.clear(this.glContext.COLOR_BUFFER_BIT);\r\n        */\r\n\r\n        this.glContext.viewport(0, 0, this.glContext.width, this.glContext.height);\r\n\r\n        //Draw Graphs\r\n        var currentIdx = 0;\r\n        var x = 0;\r\n        var y = 0;\r\n        \r\n        var vertices = [];\r\n        var tempArray = [];\r\n        var c = 0;\r\n        var i = 0;\r\n        var drawnChannels = 0;\r\n        \r\n        for (c = 0; c < this.currentPeakArray.length; c++){\r\n            if (!this.channelEnabled[c])\r\n                continue;\r\n            \r\n            startY= halfHeight * (drawnChannels * 2 + 1) + \r\n                    (this.props.margin * drawnChannels) + \r\n                    topMargin + \r\n                    this.timelineHeight;\r\n\r\n            //Draw graph\r\n            for(i = 0; i < clearWidth; i++){\r\n                currentIdx = Math.floor((this.peakPosition - clearWidth) + i);\r\n                if (currentIdx > this.currentPeakArray[c].length || (len - clearWidth + i < 0))\r\n                    continue;\r\n\r\n                x = Math.floor(widthStep * (len - clearWidth + i) + this.textWidth);\r\n                y = Math.floor((this.currentPeakArray[c][currentIdx] * halfHeight) + startY);\r\n                tempArray.push(x);\r\n                tempArray.push(y);\r\n            }\r\n\r\n            //Filter\r\n            if (this.currentFile)\r\n                this.notchFilter(tempArray, 50, 10, this.currentFile.sampleRate);\r\n\r\n            //Copy to vertex array\r\n            for (i = 0; i < tempArray.length; i++){\r\n                vertices.push(tempArray[i]);\r\n            }\r\n            tempArray = [];\r\n            vertices.push(this.props.width);\r\n            vertices.push(NaN);\r\n\r\n            drawnChannels++;\r\n        }\r\n\r\n        //Set shader attributes\r\n        this.glContext.enableVertexAttribArray(this.coordAttr);\r\n        this.glContext.vertexAttribPointer(this.coordAttr, 2, this.glContext.FLOAT, false, 0, 0);\r\n        this.glContext.uniform2f(this.resolutionUniform, this.glContext.width, this.glContext.height);\r\n        \r\n        // Pass the vertex data to the buffer\r\n        this.glContext.bindBuffer(this.glContext.ARRAY_BUFFER, this.vertexBuffer);\r\n        this.glContext.bufferData(this.glContext.ARRAY_BUFFER, new Float32Array(vertices), this.glContext.STATIC_DRAW);\r\n        this.glContext.drawArrays(this.glContext.LINE_STRIP, 0, Math.floor(vertices.length / 2));\r\n    \r\n        //Copy back buffer to front buffer\r\n        this.viewContext.fillStyle = 'black';\r\n        this.viewContext.fillRect(0, 0, this.props.width, this.props.height);\r\n        this.viewContext.drawImage(this.bufferCanvas, 0, -this.verticalScrollPos);\r\n\r\n        if (isUpdateGrid)\r\n            this.drawGrid();\r\n    }\r\n\r\n    drawGrid(){\r\n        var channelCount = this.props.channels > this.currentPeakArray.length ? this.currentPeakArray.length : this.props.channels;\r\n\r\n        var width = this.props.width - this.textWidth;\r\n        var currentHeight = Math.max(50, (this.props.height - this.timelineHeight - (this.props.margin * channelCount)) / channelCount);\r\n        var halfHeight = currentHeight / 2;\r\n\r\n        var startY = 0;\r\n        var topMargin = Math.max(this.props.height - this.timelineHeight - ((currentHeight + this.props.margin) * channelCount), 0) / 2;\r\n        \r\n        var c = 0;\r\n        var drawnChannels = 0;\r\n\r\n        this.gridContext.fillStyle = 'white';\r\n        this.gridContext.clearRect(0, 0, this.props.width, this.props.height);\r\n\r\n        for (c = 0; c < this.currentPeakArray.length; c++){\r\n            if (!this.channelEnabled[c])\r\n                continue;\r\n            \r\n            startY = halfHeight * (drawnChannels * 2 + 1) + (this.props.margin * drawnChannels) + topMargin + this.timelineHeight - this.verticalScrollPos;\r\n            \r\n            if (startY < -1 * currentHeight - this.props.margin){\r\n                drawnChannels++;\r\n                continue;\r\n            }\r\n            else if (startY > this.props.height)\r\n                break;\r\n            \r\n            //Draw canvas channel text\r\n            this.gridContext.fillText(this.channelNames[c], 0, startY);\r\n            //this.gridContext.moveTo(startX, (this.currentPeakArray[c][Math.max(this.peakOffset, 0)] * halfHeight) + startY);\r\n\r\n            drawnChannels++;\r\n        }\r\n\r\n        //Draw Canvas Grids\r\n        var y = this.timelineHeight;\r\n\r\n        this.gridContext.beginPath();\r\n        this.gridContext.strokeStyle = 'red';\r\n        this.gridContext.lineWidth = 0.5;\r\n        for (c = 0; c < channelCount; c++){\r\n            y = c * (currentHeight + this.props.margin) + this.timelineHeight + topMargin - this.verticalScrollPos;\r\n\r\n            this.gridContext.moveTo(this.textWidth, y);\r\n            this.gridContext.lineTo(this.textWidth + width, y);\r\n            \r\n            y += currentHeight;\r\n            this.gridContext.moveTo(this.textWidth, y);\r\n            this.gridContext.lineTo(this.textWidth + width, y);\r\n        }\r\n        this.gridContext.stroke();\r\n    }\r\n\r\n    //etc\r\n    getCanvas(){\r\n        return this.canvasRef.current;\r\n    }\r\n\r\n    notchFilter(arr, notchFreq, bandwidth, sampleFreq){\r\n        var filtered = [];\r\n\r\n        // Calculate biquad IIR filter coefficients.\r\n        var d = Math.exp(-Math.PI * bandwidth / sampleFreq);\r\n        \r\n        var a1 = -(1.0 + d * d) * Math.cos(2.0 * Math.PI * notchFreq / sampleFreq);\r\n        var a2 = d * d;\r\n        var b0 = (1 + d * d) / 2.0;\r\n        var b1 = a1;\r\n        var b2 = b0;\r\n        \r\n        var i = 2;\r\n        \r\n        //Filter\r\n        var value = 0;\r\n\r\n        filtered.push(arr[0]);\r\n        filtered.push(arr[1]);\r\n        for (i = 2; i < arr.length; i++){\r\n            value = b0 * arr[i] +\r\n                    b1 * arr[i - 1] + \r\n                    b2 * arr[i - 2] -\r\n                    a1 * filtered[i - 1] -\r\n                    a2 * filtered[i - 2];\r\n            filtered.push(value);\r\n        }\r\n\r\n        //Copy to arr\r\n        for (i = 0; i < arr.length; i++){\r\n            arr[i] = filtered[i];\r\n        }\r\n    }\r\n\r\n    render(){\r\n        var style={\r\n            display: 'flex',\r\n            flexDirection: 'column',\r\n        };\r\n        var graphStyle={\r\n            display: 'flex',\r\n            zIndex: '1',\r\n            minHeight: Math.floor(this.props.height) + 'px'\r\n        };\r\n        var gridStyle={\r\n            display: 'flex',\r\n            position: 'absolute',\r\n            zIndex: '2'\r\n        };\r\n        var scrollStyle={\r\n            display: 'flex',\r\n            position: 'relative',\r\n            zIndex: '3'\r\n        };\r\n\r\n        if (this.glContext !== null)\r\n            this.resizebuffer();\r\n\r\n        return (\r\n        <div style={style}>\r\n            <div style={style}>\r\n                <canvas ref={this.canvasRef} style={graphStyle} id='graphCanvas'\r\n                width={this.props.width} height={Math.floor(this.props.height)/*this.props.channels * (this.props.height + this.props.margin) + this.timelineHeight*/}/>\r\n                <canvas ref={this.gridCanvasRef} style={gridStyle} id='gridCanvas'\r\n                width={this.props.width} height={Math.floor(this.props.height)}/>\r\n            </div>\r\n            <ScrollBar ref={ref=>{this.scrollBarRef = ref;}} style={scrollStyle}\r\n            width={this.props.width} height='20'\r\n            handleWidth={this.count / (this.peakLength + this.count / 2)}\r\n            \r\n            onDrag={this.setoffset}/>\r\n        </div>);\r\n    }\r\n}\r\n\r\nexport default GLGraph;"]},"metadata":{},"sourceType":"module"}